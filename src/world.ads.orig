------------------------------------------------------------------------------
-- Common declarations across most of SparForte/BUSH including              --
-- command line switches and the symbol table.                              --
--                                                                          --
--                                                                          --
-- Part of SparForte                                                        --
------------------------------------------------------------------------------
--                                                                          --
--              Copyright (C) 2001-2022 Free Software Foundation            --
--                                                                          --
-- This is free software;  you can  redistribute it  and/or modify it under --
-- terms of the  GNU General Public License as published  by the Free Soft- --
-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
-- sion.  This is distributed in the hope that it will be useful, but WITH- --
-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
-- for  more details.  You should have  received  a copy of the GNU General --
-- Public License  distributed with this;  see file COPYING.  If not, write --
-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
-- MA 02111-1307, USA.                                                      --
--                                                                          --
-- This is maintained at http://www.pegasoft.ca                             --
--                                                                          --
------------------------------------------------------------------------------

with system,
  ada.numerics.float_random,
  ada.unchecked_deallocation,
  ada.strings.unbounded,
  ada.calendar,
  pegasoft.gen_list,
  software_models,
  pegasock.memcache,
  spar_os;
use ada.strings.unbounded,
  ada.calendar,
  software_models,
  pegasock.memcache,
  spar_os;
#if APQ
  with APQ;
  use APQ;
#end if;

package world is

------------------------------------------------------------------------------
-- Global Variables / Flags
------------------------------------------------------------------------------

version   : constant string  := "2.5";
released  : constant boolean := $configreleased;
buildDate : constant string  := $configbuilddate;
copyright : constant string  :=  " Copyright (c)2001-2022 Free Software Foundation";

globalConfigPath  : constant string := "/etc/sparforte_config";
globalPolicyPath  : constant string := "/etc/sparforte_policy";
globalProfilePath : constant string := "/etc/sparforte_profile";

random_generator : ada.numerics.float_random.generator;

type line_count is new long_long_integer;


------------------------------------------------------------------------------
-- Console Messages (e.g. error messages)
------------------------------------------------------------------------------

type messageStrings is record
   templateMessage : unbounded_string;
   gccMessage  : unbounded_string;
   --wrapPoint : natural := 0;
end record;

nullMessageStrings : constant messageStrings := messageStrings'(
   null_unbounded_string, null_unbounded_string);

------------------------------------------------------------------------------
-- Unbounded String Constants
------------------------------------------------------------------------------

chain_count_str   : constant unbounded_string := to_unbounded_string( "chain count" );
last_in_chain_str : constant unbounded_string := to_unbounded_string( "last in chain" );
return_value_str  : constant unbounded_string := to_unbounded_string( "return value" );
affirm_clause_str : constant string := "affirm clause";
sessions_session_variable_name_str : constant unbounded_string := to_unbounded_string( "sessions.session_variable_name" );
sessions_session_variable_value_str : constant unbounded_string := to_unbounded_string( "sessions.session_variable_value" );


--
-- Decimal type for formatted numbers
--

type integerOutputType is delta 0.1 digits System.Max_Digits-2;
--   delta can't be 1, so we'll settle for 0.1.  This is the largest
--   long float number we can convert to an integer (and vice vera)
--   without rounding or resorting to scientific notation.  Why
--   -2? Anything higher resulted in rounding of Max_Int and Min_Int.

type anInputMode is ( interactive, breakout, fromScriptFile );
-- interactive - user is typing commands from the prompt
-- fromScriptFile - commands are executing from a script file

--type optionalIdentifier is new integer range 0..30_000;
--noIdentifier : constant optionalIdentifier := 0;

type identifier is new integer range 1..30_000;
-- was 1..2750;
-- identifiers are identified by a unique number.  The upper bound indicates
-- the number of identifiers that can be declared.

subtype reservedWordRange is identifier range 1..8192;
-- The limit of how many reserved words can be stored in the identifiers

------------------------------------------------------------------------------
-- Interpreting and Parsing
------------------------------------------------------------------------------

trace            : boolean := false;      -- true if trace is on
inputMode        : anInputMode := interactive;
syntax_check     : boolean := false;      -- true if syntax checking
breakoutContinue : boolean := false;      -- true if execution should continue
isLoginShell     : boolean := false;      -- true if a login shell
stepFlag1        : boolean := false;      -- first parser step cmd flag
stepFlag2        : boolean := false;      -- second parser step cmd flag
isTesting        : boolean := false;      -- true if running a pragma test

-- Often the syntax_check phase is all that is required to deterime if
-- we checking or executing the source code.  In the case of some parts
-- of the parser, such as certain pragmas, we need to strictly know if
-- this is the syntax check phase or the execution phase.

type interpreterPhases is ( initializing, compiling, checking, executing );
interpreterPhase : interpreterPhases := initializing;

type scriptTypes is ( unstructured, structured );
-- scripts may be unstructured or structured.  This becomes structured
-- when a main program is encountered.

scriptType : ScriptTypes := unstructured;

------------------------------------------------------------------------------
-- Scanning
------------------------------------------------------------------------------

type aLineNumber is new natural;          -- a byte code line number
type aStatusCode is new integer;          -- a shell status code

token       : identifier;                 -- item we're currently looking at

done        : boolean := false;           -- true if exiting script
error_found : boolean := false;           -- true if an error occurred
done_sub    : boolean := false;           -- true if done a subprogram
exit_block  : boolean := false;           -- true if "exit"ing
skipping_block : boolean := false;        -- true if skipping conditional code
exception_handler : boolean := false;     -- true if handling an exception
last_status : aStatusCode := 0;           -- status of last shell command
tabSize     : natural := 8;               -- how many spaces for a tab

-- type checking is required during syntax check phase or at interactive
-- prompt

type_checks_done : boolean := false;      -- true if type checking not required

-- Source Files List
--
-- The byte code compiler permits for multiple source files to be built at
-- one time (though there is no way to specify multiple source files yet).
-- We need to maintain a globally-accessible linked list of the names of
-- loaded source files to identify where byte code lines originated from.
-- We're using a record for allow storing additional information in the future.

type aSourceFile is record                -- source file info
     pos  : natural;                      -- for identifying includes
     name : unbounded_string;             -- name of the source file
end record;
-- note: POS should be a byte code position

function ">="( left, right : aSourceFile ) return boolean;

function equal( left, right : aSourceFile ) return boolean;

package SourceFilesList is new pegasoft.gen_list( aSourceFile, equal,  ">=" );

sourceFiles : SourceFilesList.List;
-- the list of source files

commandLineSource : constant string := "Command";
-- name for a "script" (command) typed at the command prompt

sessionImportScript   : unbounded_string := null_unbounded_string;
sessionExportScript   : unbounded_string := null_unbounded_string;

------------------------------------------------------------------------------
-- Exceptions
------------------------------------------------------------------------------

-- errors reading profile files
BAD_PROFILE : exception;

-- internal errors
SPARFORTE_ERROR : exception;

-- errors reading a script
BAD_SCRIPT : exception;

------------------------------------------------------------------------------
-- Pragma Flags
------------------------------------------------------------------------------

onlyAda95                        : boolean := false; -- pragma ada_95
restriction_annotations_not_optional : boolean := false; -- pragma restriction
restriction_no_annotate_todos    : boolean := false; -- pragma restriction
restriction_no_declarations      : boolean := false; -- pragma restriction
restriction_no_auto_declarations : boolean := false; -- pragma restriction
restriction_no_unused_identifiers: boolean := false; -- pragma restriction
restriction_no_external_commands : boolean := false; -- pragma restriction
restriction_no_memcache          : boolean := false; -- pragma restriction
restriction_no_mysql_database    : boolean := false; -- pragma restriction
restriction_no_postgresql_database: boolean := false; -- pragma restriction
restriction_no_volatiles         : boolean := false; -- pragma restriction
no_command_hash                  : boolean := false; -- pragma restriction
suppress_word_quoting            : boolean := false; -- pragma suppress
suppress_no_empty_command_subs   : boolean := false; -- pragma suppress
allowLowPriorityTodosForRelease  : boolean := false; -- pragma suppress
allowAllTodosForRelease          : boolean := false; -- pragma suppress

type templateTypes is (noTemplate, htmlTemplate, textTemplate,
cssTemplate, jsTemplate, jsonTemplate, wmlTemplate, xmlTemplate,
yamlTemplate, tomlTemplate );

depreciatedMsg   : unbounded_string := null_unbounded_string; -- pragma dep.
annotationsFound : boolean := false; -- pragma annotations_not_optional
annotationTodoFound : boolean := false; -- pragma annotations_no_todo
licenseSet       : boolean := false;
softwareModelSet : boolean := false;
softwareModelReq : softwareModelPtr := null;

------------------------------------------------------------------------------
-- DESIGN CONSTRAINTS
--
-- A constraint has a mode, category, name and a limit.
------------------------------------------------------------------------------

type designConstraintModes is (
   undefined, unique, file, subprogram
);

function toConstraintMode( s : unbounded_string ) return designConstraintModes;

type aDesignConstraint is record
    mode       : designConstraintModes;
    constraint :  unbounded_string;
    name       : unbounded_string;
    limit      : float;
end record;

function ">="( left, right : aDesignConstraint ) return boolean;

function equal( left, right : aDesignConstraint ) return boolean;

package DesignConstraintLists is new pegasoft.gen_list( aDesignConstraint, equal,  ">=" );

-- value indicating asserted constraint exists

noDesignConstraint : constant natural := 0;

type anEnforcedDesignConstraint is record
    mode         : designConstraintModes;         -- how strict
    enforcedAt   : natural := noDesignConstraint; -- line enforced
    enforcedFile : unbounded_string;              -- file enforced
    enforcedUnit : unbounded_string;              -- subr enforced (local only)
    constraint   : unbounded_string;
    name         : unbounded_string;
    weight       : float;
end record;

function ">="( left, right : anEnforcedDesignConstraint ) return boolean;

function equal( left, right : anEnforcedDesignConstraint ) return boolean;

package EnforcedDesignConstraintLists is new pegasoft.gen_list( anEnforcedDesignConstraint, equal,  ">=" );

package EnforcedLocalDesignConstraintLists is new pegasoft.gen_list( anEnforcedDesignConstraint, equal,  ">=" );

------------------------------------------------------------------------------
-- DESIGN AFFINITIES
--
-- An affinity has a mode, name and goal.
------------------------------------------------------------------------------

type designAffinityModes is (
   undefined, file, subprogram
);

function toAffinityMode( s : unbounded_string ) return designAffinityModes;

type aDesignAffinity is record
    mode       : designAffinityModes;
    affinity   : unbounded_string;
    limit      : float;
end record;

function ">="( left, right : aDesignAffinity ) return boolean;

function equal( left, right : aDesignAffinity ) return boolean;

package DesignAffinityLists is new pegasoft.gen_list( aDesignAffinity, equal,  ">=" );

-- value indicating asserted constraint exists

noDesignAffinity : constant natural := 0;

type anEnforcedDesignAffinity is record
    mode         : designAffinityModes;           -- how strict
    enforcedAt   : natural := noDesignAffinity;   -- line enforced
    enforcedFile : unbounded_string;              -- file enforced
    enforcedUnit : unbounded_string;              -- subr enforced (local only)
    affinity     : unbounded_string;
    weight       : float;
end record;

function ">="( left, right : anEnforcedDesignAffinity ) return boolean;

function equal( left, right : anEnforcedDesignAffinity ) return boolean;

package EnforcedDesignAffinityLists is new pegasoft.gen_list( anEnforcedDesignAffinity, equal,  ">=" );

package EnforcedLocalDesignAffinityLists is new pegasoft.gen_list( anEnforcedDesignAffinity, equal,  ">=" );


------------------------------------------------------------------------------
-- Templates
--
-- These are set by pragma template, etc.
------------------------------------------------------------------------------

type httpStatusCodes is new natural range 100..505;

type templateHeaders is record
     templateType  : TemplateTypes;
     status        : httpStatusCodes;
     contentLength : unbounded_string;
     expires       : unbounded_string;
     location      : unbounded_string;
     pragmaString  : unbounded_string;
     cookieString  : unbounded_string;
     templateHeaderSent : boolean := false;
end record;

hasTemplate          : boolean := false; -- has a pragma template
processingTemplate   : boolean := false; -- pragma tempate
unrestrictedTemplate : boolean := false; -- pragma unrestricted_t
templatePath         : unbounded_string; -- template path

templateHeader       : templateHeaders;

------------------------------------------------------------------------------
-- Command Line Options
--
-- These are set when BUSH interprets its command line options
------------------------------------------------------------------------------

type commandLineOption is new boolean;

breakoutOpt  : commandLineOption := false;           -- true if -b
syntaxOpt    : commandLineOption := false;           -- true if -c
codingOpt    : commandLineOption := false;           -- true if -C
debugOpt     : commandLineOption := false;           -- true if -d
testOpt      : commandLineOption := false;           -- true if -D
execOpt      : commandLineOption := false;           -- true if -e
gccOpt       : commandLineOption := false;           -- true if -g
importOpt    : commandLineOption := false;           -- true if -i
maintenanceOpt : commandLineOption := false;         -- true if -m
perfOpt      : commandLineOption := false;           -- true if -p
profileOpt   : commandLineOption := false;           -- true if -P
quietOpt     : commandLineOption := false;           -- true if -q
rshOpt       : commandLineOption := false;           -- true if -r
verboseOpt   : commandLineOption := false;           -- true if -v
designOpt    : commandLineOption := false;           -- true if -t
traceOpt     : commandLineOption := false;           -- true if -x
colourOpt    : commandLineOption := false;           -- true if --colour/--color

sessionName  : unbounded_string  := null_unbounded_string; -- session name

--optionOffset : natural := 0;     -- character offset to script parameters

terminalWindowNaming : boolean := false;
-- true if terminal emulation supports xterm window naming

#if APQ
currentEngine : Database_Type; --:= Engine_PostgreSQL;
#else
-- APQ disabled.  All we need are dummy values here
type Database_Type is ( Engine_PostgreSQL, Engine_MySQL, Engine_None );
currentEngine : Database_Type := Engine_None;
#end if;
engineOpen    : boolean := false;
-- current database being used.  Unfortunately, APQ has no Engine_None so we
-- need two variables.

libraryPath : Unbounded_String;
-- list of library directories (-L) from command line

lastChild : aPID := 0;
-- the process ID of the last child process (i.e. command with ampersand)

------------------------------------------------------------------------------
-- Identifiers (The Symbol Table)
--
------------------------------------------------------------------------------
--
-- Identifier classes
--
--   constClass    - a constant (removed 17/11/14)
--   subClass      - a subtype
--   typeClass     - a type
--   funcClass     - a function
--   procClass     - a procedure
--   userProcClass - a user-defined procedure
--   taskClass     - a task
--   exceptionClass - an exception
--   varClass      - a variable
--   namespaceClass - a namespace marker
--   enumClass     - an enumerated item
--   policyClass   - a policy block
--   configurationClass - a configuration block
--   formalParamClass - formal parameters
--   otherClass    - an undefined class

type anIdentifierClass is ( subClass, typeClass, funcClass,
  userFuncClass, procClass, userProcClass, taskClass, mainProgramClass,
  exceptionClass, varClass, namespaceClass, enumClass, policyClass,
  configurationClass, genericTypeClass, formalParamClass, userCaseProcClass,
  otherClass );

function getIdentifierClassImage( c : anIdentifierClass ) return string;

------------------------------------------------------------------------------
--
-- DataFlows (renamed from Threads)
--
-- Not actually threads, but for tracking asynchronous actions for
-- side-effects.  Threads include contracts.

subtype aDataFlowName is unbounded_string;

noDataFlow : aDataFlowName := to_unbounded_string( "none" );
mainDataFlow : aDataFlowName := to_unbounded_string( "main task" );

-- Expression Instruction
--
-- The instruction number of the last expression to execute (if any).

noExpressionInstruction : constant line_count := line_count'last;
-- start of latest expression
lastExpressionInstruction : line_count;
-- start of top-most expression
firstExpressionInstruction : line_count;

------------------------------------------------------------------------------
--
-- Import/Export Methods
-- Note: http_cgi to avoid ambiguity over "cgi" package name

type anImportMethod is ( none, shell, http_cgi, local_memcache, memcache, session );
type anImportMapping is ( none, json );

------------------------------------------------------------------------------
--
-- Usage Qualifier
--
-- Limits on how an identifier may be used.
--
-- fullUsage     - read/write
-- abstractUsage - no declarations (legal only for types)
-- limitedUsage  - no expressions or assignment
-- constUsage    - read only (a constant)

type aUsageQualifier is ( fullUsage, abstractUsage, limitedUsage, constantUsage );

------------------------------------------------------------------------------
--
-- Callbacks to execute a build-in procedure or function (such as put_line).

type aBuiltinProcedureCallback is access procedure;
type aBuiltinFunctionCallback is access procedure( value : out unbounded_string; kind : out identifier );

-- Each identifier has a single-dimension array of strings to hold the
-- identifier's value(s)

type storage is array( long_integer range <>) of aliased unbounded_string;
type storagePtr is access all storage;
procedure free is new ada.unchecked_deallocation( storage, storagePtr );
type valuePtr is access all unbounded_string;

function findStorage( lbound, ubound : long_integer ) return storagePtr;
pragma inline( findStorage );
-- find/allocate storage

-- Ways to pass parameters

type aParameterPassingMode is (none, in_mode, out_mode, in_out_mode );

function to_string( mode : aParameterPassingMode ) return string;

-- Types of volatility

type aVolatileMode is (none, unchecked, checked);

-- value indicating no forward specification exists

noSpec : constant natural := 0;

------------------------------------------------------------------------------
-- Identifier Declarations
--
-- Optimization note: at least as of GNAT 4.6 on 64-bit Intel, using pointers
-- is about 4 times slower on sequential searches than using array indexes.
------------------------------------------------------------------------------
type declaration;

type declaration is record
     name            : unbounded_string        -- identifier's name
                := Null_Unbounded_String;
     value           : valuePtr := null;       -- identifier's value
     --value    : unbounded_string                -- identifier's value
     --           := Null_Unbounded_String;
     kind            : identifier;              -- identifier's type
     class           : anIdentifierClass        -- identifier's class
                       := otherClass;
     import          : boolean := false;        -- marked by pragma import
     method          : anImportMethod := none;  -- where to import values
     mapping         : anImportMapping := none; -- how to translate on import
     export          : boolean := false;        -- marked by pragma export
     volatile        : aVolatileMode := none;   -- marked by pragma volatile
                                                --   or unchecked_volatile
     volatileTTL     : duration := 0.0;         -- period assumed safe
     volatileExpire  : time;                    -- time of next reload
                                                -- (may be undefined)
     static          : boolean := false;        -- if value is known at syn chk
     usage           : aUsageQualifier := fullUsage; -- limits on use
     list            : boolean := false;        -- array or array type
     resource        : boolean := false;        -- resource type
     field_of        : identifier;              -- record superclass
     inspect         : boolean := false;        -- show value on breakout
     deleted         : boolean := false;        -- marked for deletion
     specAt          : natural := noSpec;       -- line where forward spec
     specFile        : unbounded_string         -- file of forward spec
                       := Null_Unbounded_String;
     wasReferenced   : boolean := false;        -- true if ref'd in syn chk
     wasWritten      : boolean := false;        -- true if written in syn chk
     writtenByFlow   : aDataFlowName;
     writtenOn       : line_count;              -- side-effect protection
                                                --   when last written to
     wasApplied      : boolean := false;        -- true if type was used
     wasFactor       : boolean := false;        -- true if used in expression
     wasCastTo       : boolean := false;        -- true if used in typecast
     renaming_of     : identifier := identifier'first; -- renaming or dereference
     -- TODO: renaming should be a reference
     -- TODO: renaming should be about storage, not dereference whole ident
     renamed_count   : natural := 0;            -- number of times renamed
     passingMode     : aParameterPassingMode    -- in, out, in out, none
                       := none;

     -- New fields for symbol table

     procCB   : aBuiltinProcedureCallback := null;  -- built-in proc CB
     funcCB   : aBuiltinFunctionCallback := null;  -- built-in func CB
     genKind         : identifier;              -- generic type (if any)
     genKind2        : identifier;              -- generic type (if any)
     firstBound      : long_integer := 1;       -- first bound (array type only)
     lastBound       : long_integer := 0;       -- last bound (array type only)

     -- Programming by Contract

     contract : unbounded_string;               -- executable block

     -- Storage

     avalue    : storagePtr := null;             -- array value (array variable)
     svalue    : aliased unbounded_string;       -- identifier's value

     -- Namespaces

     openNamespace : identifier := identifier'first;       -- corresponding open (or null)
     nextNamespace : identifier := identifier'first;       -- next tag (descending)
     parentNamespace : identifier := identifier'first;     -- parent open tag
end record;


------------------------------------------------------------------------------
-- Error Handling
------------------------------------------------------------------------------

-- error_type    : anExceptionType;                       -- type of exception
err_message      : unbounded_string;                     -- last error message
fullErrorMessage : messageStrings;                  -- same with location info
err_exception    : declaration;           -- the exception else eof_t for none
-- err_exception must be a declaration because it can be propogated out of
-- the exception declaration scope


------------------------------------------------------------------------------
-- Symbol Table
--
------------------------------------------------------------------------------

type identifiersArray is array ( identifier ) of declaration;

identifiers     : identifiersArray;
identifiers_top : identifier := identifier'first;
keywords_top    : identifier := identifier'last; -- last Ada keyword (xor)
reserved_top    : identifier := identifier'last; -- last keyword any kind
predefined_top  : identifier := identifier'last; -- last predefined ident
                                                 -- (like last built-in fn)
-- this arrangement means the last array element is never accessed

-- "Captain, the ship can't take any more!"

symbol_table_overflow : exception;

------------------------------------------------------------------------------
-- Identifier References
--
-- These are for working with aggregate types, such as params passed into
-- pre-defined functions.
------------------------------------------------------------------------------

-- a scalar reference

type reference is record
     id    : identifier;             -- the identifier
     index : long_integer := 0;      -- the array index (if an array)
     kind  : identifier;             -- the type name
end record;

-- a scalar or aggregate reference
--
-- This is done separately to avoid feature creep.  I don't want to
-- re-engineer references at this time.

type renamingReference is record
     id    : identifier;             -- the identifier
     hasIndex : boolean := false;    -- true if index
     index : long_integer := 0;      -- the array index (if an array)
     kind  : identifier;             -- the type name
end record;

------------------------------------------------------------------------------
-- Block Table
--
-- The block table is defined in scanner.ads but the declarations are here
-- because the block number is sometimes stored (for example, in arrays)
-- so we need the block id's to have larger scope.
------------------------------------------------------------------------------
type block is new integer range 1..32; -- The block nesting level
block_table_overflow : exception;      -- Too many blocks

------------------------------------------------------------------------------
-- Predefined Identifiers (Global)
--
-- These identifiers always have meaning and are accessible from all other
-- packages.  They represent keywords and other unchangable declarations
-- in the symbol table.
--
-- Keyword is the root of all identifiers in the symbol table tree.  It is
-- the type for any AdaScript keyword.
------------------------------------------------------------------------------

keyword_t : identifier;


------------------------------------------------------------------------------
-- Keywords
--
-- All Ada95 keywords are reserved even if they are not used by AdaScript
------------------------------------------------------------------------------

abort_t    : identifier;
abs_t      : identifier;
abstract_t : identifier;
accept_t   : identifier;
access_t   : identifier;
aliased_t  : identifier;
all_t      : identifier;
and_t      : identifier;
array_t    : identifier;
at_t       : identifier;
begin_t    : identifier;
body_t     : identifier;
case_t     : identifier;
constant_t : identifier;
declare_t  : identifier;
delay_t    : identifier;
delta_t    : identifier;
digits_t   : identifier;
do_t       : identifier;
else_t     : identifier;
elsif_t    : identifier;
end_t      : identifier;
entry_t    : identifier;
exception_t : identifier;
exit_t     : identifier;
for_t      : identifier;
function_t : identifier;
generic_t  : identifier;
goto_t     : identifier;
if_t       : identifier;
in_t       : identifier;
is_t       : identifier;
limited_t  : identifier;
loop_t     : identifier;
mod_t      : identifier;
new_t      : identifier;
not_t      : identifier;
null_t     : identifier;
of_t       : identifier;
or_t       : identifier;
others_t   : identifier;
out_t      : identifier;
package_t  : identifier;
pragma_t   : identifier;
private_t  : identifier;
procedure_t : identifier;
protected_t : identifier;
raise_t    : identifier;
range_t    : identifier;
record_t   : identifier;
rem_t      : identifier;
renames_t  : identifier;
requeue_t  : identifier;
return_t   : identifier;
reverse_t  : identifier;
select_t   : identifier;
separate_t : identifier;
subtype_t  : identifier;
tagged_t   : identifier;
task_t     : identifier;
terminate_t : identifier;
then_t     : identifier;
type_t     : identifier;
until_t    : identifier;
use_t      : identifier;
when_t     : identifier;
while_t    : identifier;
with_t     : identifier;
xor_t      : identifier;

------------------------------------------------------------------------------
--  AdaScript-specific keywords
------------------------------------------------------------------------------

affirm_t   : identifier;
copies_t   : identifier;
configuration_t : identifier;
policy_t   : identifier;

------------------------------------------------------------------------------
--  Built-in Bourne shell commands
--
-- AdaScript shell commands that extend Ada 95 are also reserved words
------------------------------------------------------------------------------

env_t      : identifier;
typeset_t  : identifier;
umask_t    : identifier;
unset_t    : identifier;
trace_t    : identifier;
help_t     : identifier;
clear_t    : identifier;
jobs_t     : identifier;
logout_t   : identifier;
pwd_t      : identifier;  -- built-in pwd
cd_t       : identifier;  -- built-in cd
wait_t     : identifier;  -- built-in wait
step_t     : identifier;
-- template_t : identifier;
history_t  : identifier;  -- built-in history

------------------------------------------------------------------------------
--  Built-in SQL commands
--
------------------------------------------------------------------------------

alter_t  : identifier;
insert_t : identifier;
delete_t : identifier; -- (shared with Ada.Text_IO delete)
--select_t : identifier; -- (shared with Ada select declared above)
update_t : identifier;

-- Additional keywords not used by SparForte but are in Ada

interface_t    : identifier; -- Ada 2005
overriding_t   : identifier; -- Ada 2005
synchronized_t : identifier; -- Ada 2005
some_t         : identifier; -- Ada 2012

------------------------------------------------------------------------------
-- Other internal identifiers
--
-- EOF token, literals and virtual machine instructions.  Users should never
-- see these but they are all defined in the symbol table.
------------------------------------------------------------------------------

eof_t      : identifier;  -- end of file / abort script
symbol_t   : identifier;  -- punctuation/etc., value = string of punctuation
backlit_t  : identifier;  -- back quoted literal, value = the literal
strlit_t   : identifier;  -- string literal, value = the literal
charlit_t  : identifier;  -- character literal, value = the literal
number_t   : identifier;  -- numeric literal, value = the literal
imm_delim_t: identifier;  -- immediate word delimiter / identifier terminator
imm_sql_delim_t: identifier;  -- same for SQL word
imm_symbol_delim_t : identifier; -- same for shell symbols
word_t     : identifier;  -- immediate word value
sql_word_t : identifier;  -- a SQL word (not to be escaped)
char_escape_t : identifier; -- character escape
shell_symbol_t : identifier; -- shell symbol like "2>&1"


------------------------------------------------------------------------------
-- Predefined types
--
-- All Ada 95 fundamental types are declared, as well as AdaScript extensions.
--
-- variable_t is the root type of all variables and
-- is only used to mark the fundamental types.
--
-- the fundamental types are univeral number, universal
-- string and universal (typeless).  All have .kind =
-- variable_t.
--
-- the basic Ada types are derived from the universal
-- types and have a .kind = some univeral type.
--
-- user types are, of course, derived from the basic
-- Ada types and have a .kind = some basic Ada type
------------------------------------------------------------------------------

variable_t            : identifier;

uni_numeric_t         : identifier;
uni_string_t          : identifier;
universal_t           : identifier;
root_enumerated_t     : identifier;
root_record_t         : identifier;
command_t             : identifier;

file_type_t           : identifier;
socket_type_t         : identifier;
integer_t             : identifier;
natural_t             : identifier;
positive_t            : identifier;
short_short_integer_t : identifier;
short_integer_t       : identifier;
long_integer_t        : identifier;
long_long_integer_t   : identifier;
character_t           : identifier;
float_t               : identifier;
short_float_t         : identifier;
long_float_t          : identifier;
boolean_t             : identifier;
string_t              : identifier;
duration_t            : identifier;
file_mode_t           : identifier;
unbounded_string_t    : identifier;
complex_t             : identifier;
complex_real_t        : identifier;
complex_imaginary_t   : identifier;

false_t               : identifier; -- Boolean.false
true_t                : identifier; -- Boolean.true

json_string_t         : identifier;

------------------------------------------------------------------------------
-- Shortcut operands
--
-- The reflexive operand, itself, "@":
--
--   If itself's class is otherClass, it refers to a variable.
--     eg. total := @+1;  itself is the value, itself_type is the type
--   If itself's class is procClass, it refers to a procedure.
--     eg. put( "hello" ) @ ( "!" )  itself_type is the procedure id and
--     itself is unused
--   If itself_type is new_t, then itself is undefined.
--   To extend itself's capabilities, beware of side-effects.
------------------------------------------------------------------------------

itself      : unbounded_string;   -- copy of the identifier declaration
itself_type : identifier;         -- type of @ or procedure identifier

-- The last output operand, %

last_output : unbounded_string;   -- result of last output
last_output_type : identifier;    -- type of last output

-----------------------------------------------------------------------------
-- TINY HASH CACHE
--
-- A small identifier cache to speed up identifier symbol table lookups.
-----------------------------------------------------------------------------

--type tinyHashCacheEntry is record
--     key : unbounded_string;
--     id  : identifier;
--     cnt : natural;
--end record;
--
--type effectiveHash is new natural range 0..37;
--subtype actualHash is effectiveHash range 1..37;
--
--type aTinyHashCache is array( actualHash ) of tinyHashCacheEntry;
--
--tinyHashCache : aTinyHashCache;
--currentTinyHashCacheCnt : natural := 1;
--
--procedure resetTinyHashCache;
--procedure getTinyHashCache( s : unbounded_string; id : out identifier ; h : out actualHash );

function isExecutingCommand return boolean;
-- True if OK to execute a statement that does work.
-- That is, the parser isn't skipping the line because of
-- an error or exiting a block.
pragma inline( isExecutingCommand );

function isExecutingStaticCommand return boolean;
pragma inline( isExecutingStaticCommand );

------------------------------------------------------------------------------
-- Declarations
------------------------------------------------------------------------------

procedure declareKeyword( id : out identifier; s : string );
-- initialize a new keyword / internal identifier

procedure declareFunction( id : out identifier; s : string; cb : aBuiltinFunctionCallback := null );
-- Initialize a built-in function identifier in the symbol table

procedure declareProcedure( id : out identifier; s : string; cb : aBuiltinProcedureCallback := null );
-- Initialize a built-in procedure identifier in the symbol table

--function deleteIdent( id : identifier ) return boolean;
-- delete an identifier, true if successful
-- moved to scanner because this has become a complex operation

procedure declareIdent( id : out identifier; name : unbounded_string;
  kind : identifier; class : anIdentifierClass := varClass );
-- Declare an identifier in the symbol table, specifying name, kind.
-- and (optionally) symbol class.  The id is returned.

procedure declareIdent( id : out identifier; name : string;
  kind : identifier; class : anIdentifierClass := varClass );
-- Alternate version: use fixed string type for name

procedure declareStandardConstant( id : out identifier;
   name : string; kind : identifier; value : string );
-- Declare a standard constant in the symbol table.  The id is not
-- returned since we don't change with constants once they are set.

procedure declareStandardConstant( name : string; kind : identifier;
  value : string );
-- Alternative version: don't return the symbol table id

procedure declareStandardEnum( id : out identifier;
   name : string; kind : identifier; value : string );

procedure updateFormalParameter( id : identifier; kind : identifier;
  proc_id : identifier; parameterNumber : integer; passingMode :
  aParameterPassingMode );
-- Update a formal parameter (ie. proc.param).  The id is not
-- returned since we don't change the formal parameters once they are set.

procedure declareUsableFormalParameter( id : out identifier;
proc_id : identifier; parameterNumber : integer;
value : unbounded_string; startingAt : in out identifier  );
-- Declare a usable formal parameter (ie. param for proc.param).

procedure declareReturnResult( id : out identifier; func_id : identifier );
-- Declare space for the function return result.

type anExceptionStatusCode is new natural range 0..255;

procedure findException( name : unbounded_string; id : out identifier );
-- search for a pre-existing exception with the same name

procedure declareException( id : out identifier; name : unbounded_string;
   default_message : unbounded_string; exception_status_code : anExceptionStatusCode );
-- Declare an exception.  Check with findException first.

procedure declareRenaming( new_id : identifier; canonicalRef :
  renamingReference );
-- recast a new identifier as a renaming of the given reference

procedure declareRecordFields( parentRecordOfFieldsId, recordBaseTypeId : identifier );

procedure declareNamespace( name : string );
procedure declareGlobalNamespace;
procedure declareNamespaceClosed( name : string );
-- Declare a namespace

procedure findIdent( name : unbounded_string; id : out identifier );
-- find an identifier, eof_t if failed

procedure findEnumImage( val : unbounded_string; kind : identifier; name : out unbounded_string );
-- Find the name of the enumerated item of enumerated type kind with value
-- val.

procedure fixUsableParametersInAbstractSubprogram( sub_id : identifier );
-- Mark usable parameters as read/written in a null abstract subprogram

procedure init_env_ident( s : string );
-- initialize an environment variable

function is_keyword( id : identifier ) return boolean;
-- TRUE if the identifier is a keyword

procedure copyValue( to_decl : in out declaration; from_decl : declaration );
procedure copyValue( to_decl : in out declaration; from_id : identifier );
procedure copyValue( to_id, from_id : identifier );
-- Copy the value and type of one identifier to another

-----------------------------------------------------------------------------
-- Namespaces
--
-- These are initialized in startScanner
-----------------------------------------------------------------------------

currentNamespace    : unbounded_string;
currentNamespaceId  : identifier;
lastNamespaceId     : identifier;

-----------------------------------------------------------------------------
-- Type Representation
-----------------------------------------------------------------------------

maxInteger : long_float;
-- equivalent to BUSH's System.Max_Int, the largest integer representable
-- by BUSH (it is not long_integer'last).  Set during scanner startup.

function to_numeric( s : unbounded_string ) return long_float;
-- Convert an unbounded string to a long float (BUSH's numeric representation)

function to_numeric( id : identifier ) return long_float;
-- Look up an identifier's value and return it as a long float
-- (BUSH's numeric representation).

function to_bush_boolean( AdaBoolean : boolean ) return unbounded_string;
  -- convert an Ada boolean into a BUSH boolean (a string containing
  -- the position, no leading blank).

function to_unbounded_string( f : long_float ) return unbounded_string;
-- convert a numeric value to a bush string, dropping of decimal portion
-- if a small integer

-----------------------------------------------------------------------------
-- Character Conversion
-----------------------------------------------------------------------------

function toHighASCII( ch : character ) return character;
function toHighASCII( id : identifier ) return character;
-- add 128 to a character

function toLowASCII( ch : character ) return character;
function toLowASCII( id : identifier ) return character;
-- subtract 128 from a character

-- This is a two-character natural in the byte code with first byte
-- having >= 128 and no zeros.  This is the maximum possible number
-- of reserved words.

subtype byteCodeIdentifier is positive range 1..8192;

subtype byteCodeNatural    is natural;

procedure toByteCode( id : reservedWordRange; ch1, ch2 : out character );
function toByteCode( id : reservedWordRange ) return string;
pragma inline( toByteCode );

procedure toIdentifier( ch1, ch2 : character; id : out reservedWordRange; advance : out integer );
pragma inline( toIdentifier );


-----------------------------------------------------------------------------
-- Shell Words
-----------------------------------------------------------------------------

type aShellWordType is (
     normalWord,           -- any word that is not a special word
     semicolonWord,        -- unescaped ;
     pipeWord,             -- unescaped |
     ampersandWord,        -- unescaped &
     redirectOutWord,      -- unescaped >
     redirectInWord,       -- unescaped <
     redirectAppendWord,   -- unescaped >>      redirectErrOutWord,   -- unescaped 2>
     redirectErrOutWord,   -- unescaped 2>
     redirectErrAppendWord,-- unescaped 2>>
     redirectErr2OutWord,  -- unescaped 2>&1
     itselfWord            -- unescaped @
);
-- To differentiate between ";" and ;, "|" and |, "&" and &, etc.


type aShellWord is record
     wordType : aShellWordType;                       -- shell token type
     pattern  : unbounded_string;                     -- pattern for word
     word     : unbounded_string;                     -- expanded word
end record;

nullShellWord : aShellWord := ( normalWord, null_unbounded_string,
  null_unbounded_string );

function ">"( left, right : aShellWord ) return boolean;

package shellWordList is new pegasoft.gen_list( aShellWord, ">", "=" );

-- Enviroment
--
-- Since the O/S environment is altered while BUSH is running, save the initial
-- environment in a linked list when BUSH starts.  This is the list.

package environmentList is new pegasoft.gen_list( unbounded_string, ">", "=" );

initialEnvironment : environmentList.List;

-- Find fieldNumber'th field of a record varable.

procedure findField( recordVar : identifier; fieldNumber: natural;
  fieldVar : out identifier );

-----------------------------------------------------------------------------
-- Memcached
-----------------------------------------------------------------------------

-- PegaSock Cluster for a Local Memcache Server
-- It is only initialized if it is used in pragma import/etc.


localMemcacheCluster : aMemcacheCluster;

-- Initialize the cluster.  If it is already initialized, this has no effect

procedure checkAndInitializeLocalMemcacheCluster;

distributedMemcacheCluster : aMemcacheCluster;

procedure checkAndInitializeDistributedMemcacheCluster;

-----------------------------------------------------------------------------
-- HTTP
-----------------------------------------------------------------------------

--  PUT TEMPLATE HEADER
--
-- Output the template header.  Mark it as sent so it isn't sent
-- twice.  This will likely be replaced in the future.
--
-- A bad status results in HTTP 500.  A bad content type results in text.
-- In both cases, a message is written to standard error.
-----------------------------------------------------------------------------

procedure putTemplateHeader( header : in out templateHeaders );


------------------------------------------------------------------------------
-- Message "mark up" and escaping functions
------------------------------------------------------------------------------

function getNewLine return messageStrings;
-- get a new line appropriate for an error message

function "&"( left, right : messageStrings ) return messageStrings;
-- concatenation

function pl( s : string ) return messageStrings;
function pl( c : character ) return messageStrings;
function "+"( s : string ) return messageStrings renames pl;
-- plain text

function unb_pl( us : unbounded_string ) return messageStrings;
-- unbounded plain text

function ok( s : string ) return messageStrings;
-- success text (usually green)

function inv( s : string ) return messageStrings;
-- inverse text

function em( s : string ) return messageStrings;
-- emphasized text

function unb_em( us : unbounded_string ) return messageStrings;
-- unbounded string emphasized text

function name_em( id : identifier ) return messageStrings;
-- identifier name field, emphasized

function em_esc( s : unbounded_string ) return messageStrings;
-- escape plus emphasize

function em_value( s : unbounded_string ) return messageStrings;
-- combines bold, secured data and escaped.  A null value will
-- return double single quotes.

function qp( s : string ) return string;
-- Uppercase the first letter of the string if quiet option is in use.
-- The string is then passed to pl() or em() to turn into a message string.

procedure put_trace( msg : string; icon : string := "" );
-- display a trace message to standard error

end world;
