------------------------------------------------------------------------------
-- Reading the keyboard, writing to the terminal/console                    --
--                                                                          --
-- Part of SparForte                                                        --
------------------------------------------------------------------------------
--                                                                          --
--            Copyright (C) 2001-2021 Free Software Foundation              --
--                                                                          --
-- This is free software;  you can  redistribute it  and/or modify it under --
-- terms of the  GNU General Public License as published  by the Free Soft- --
-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
-- sion.  This is distributed in the hope that it will be useful, but WITH- --
-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
-- for  more details.  You should have  received  a copy of the GNU General --
-- Public License  distributed with this;  see file COPYING.  If not, write --
-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
-- MA 02111-1307, USA.                                                      --
--                                                                          --
-- This is maintained at http://www.pegasoft.ca                             --
--                                                                          --
------------------------------------------------------------------------------

with ada.text_io,
     ada.strings.unbounded.text_io,
     ada.calendar,
     gnat.directory_operations,
     gnat.source_info,
     ada.containers.vectors,
     spar_os.tty,
     spar_os.readline,
     world;
use  ada.text_io,
     ada.strings.unbounded.text_io,
     ada.calendar,
     gnat.directory_operations,
     spar_os,
     spar_os.tty,
     spar_os.readline,
     world;

#if not READLINE
with gnat.regexp,
     gnat.os_lib,
     signal_flags,
     string_util;
use  gnat.regexp,
     gnat.os_lib,
     signal_flags,
     string_util;
#end if;

package body user_io.getline is

#if not READLINE

-----------------------------------------------------------------------------
--  GET PROMPT INDENT (no getline library)
--
-- determine how far the command prompt indents from the
-- left hand side of the screen, taking into account
-- control characters and carriage returns / line feeds
-----------------------------------------------------------------------------

function getPromptIndent return natural is
  len : natural := 0;
begin
  for i in 1..length( prompt ) loop
      if element( prompt, i ) = ASCII.CR then      -- carriage return?
         len := 0;                                 -- back to left side
      elsif element( prompt, i ) = ASCII.LF then   -- line feed?
         len := 0;                                 -- back to left side
      elsif element( prompt, i ) >= ' ' then       -- not a control char?
         len := len + 1;                           -- count it
      end if;
  end loop;
  return len;
end getPromptIndent;


-----------------------------------------------------------------------------
--  GET PROMPT EXTRA LINES (no readline library)
--
-- determine how far the command prompt indents from the
-- left hand side of the screen, taking into account
-- control characters and carriage returns / line feeds
-----------------------------------------------------------------------------

function getPromptExtraLines return natural is
  last : character := ASCII.NUL;
  extra : natural := 0;
begin
  for i in 1..length( prompt ) loop
      if element( prompt, i ) = ASCII.CR then      -- carriage return?
         extra := extra + 1;                       -- back to left side
      elsif element( prompt, i ) = ASCII.LF then   -- line feed?
         if last /= ASCII.CR then                  -- for MS-DOS
            extra := extra + 1;                    -- back to left side
         end if;
      end if;
      last := element( prompt, i );
  end loop;
  return extra;
end getPromptExtraLines;
#end if;

#if READLINE
-----------------------------------------------------------------------------
--
-- COMPLETION LIST
--
-----------------------------------------------------------------------------
-- May be removed


package completionLists is new ada.containers.vectors( Positive,
  chars_ptr );
memoryLeakCnt : integer := 0;


-----------------------------------------------------------------------------
--
-- GIT WORD COMPLETION
--
-----------------------------------------------------------------------------

gitWords  : completionLists.Vector;
gitCursor : completionLists.Cursor;

-----------------------------------------------------------------------------
--  RESERVED WORD GENERATOR (C language callback to Ada)
--
-- C calls this Ada function to generate a list of acceptable completions
-- for the given text fragment.  A C null pointer is returned if there are
-- no more matches.
-----------------------------------------------------------------------------

function Ada_git_word_generator(text : chars_ptr; state : int ) return chars_ptr is
  use completionLists;
  needle   : constant string := To_Ada( Value( text ) );
  ptr : chars_ptr;
begin
  -- If this is a new search, move the cursor to the front of the reserved
  -- words.  Otherwise, continue advancing through the list.

  if state = 0 then
     gitCursor := completionLists.First( gitWords );
  elsif gitCursor /= completionLists.No_Element then
     gitCursor := completionLists.Next( gitCursor );
  end if;

  -- From the current position in the list, if the text matches the leading
  -- characters of the candidate word, then return the candidate word to C.
  -- Use strdup() to create a new C string which will be deallocated by
  -- GNU readline.

  while gitCursor /= completionLists.No_Element loop
     ptr := completionLists.Element( gitCursor );
     if Strlen( text ) <= Strlen( ptr ) then
        declare
           haystack : constant string := To_Ada( Value( ptr ) );
        begin
           if needle = haystack(1..needle'last) then
              return C_strdup( ptr );
           end if;
        end;
     end if;
     gitCursor := completionLists.Next( gitCursor );
  end loop;

  -- If there are no more reserved words, return a C NULL pointer to indicate
  -- there are no more possibilities.

  return Null_Ptr;
end Ada_git_word_generator;


-----------------------------------------------------------------------------
--  ASSIGNMENT WORD GENERATOR (C language callback to Ada)
--
-- Return candidate words for assignment substitutions from the symbol table.
-----------------------------------------------------------------------------

assignmentIdx : identifier:=identifiers'last;

function Ada_assignment_word_generator(text : chars_ptr; state : int ) return chars_ptr is
  needle    : constant string := To_Ada( Value( text ) );
  needleLen : constant size_t := Strlen( text );
begin
  -- If this is a new search, move the cursor to the front of the reserved
  -- words.  Otherwise, continue advancing through the list.

  if state = 0 then
     assignmentIdx := identifiers'last;
  elsif assignmentIdx > identifiers'first then
     -- Note: walks everything, even things not visible.  Perhaps not a big
     -- concern on the command line?
     assignmentIdx := assignmentIdx  - 1;
  end if;

  -- From the current position in the list, if the text matches the leading
  -- characters of the candidate word, then return the candidate word to C.
  -- Use strdup() to create a new C string which will be deallocated by
  -- GNU readline.

  while assignmentIdx > identifiers'first loop
     if needleLen <= size_t( length( identifiers( assignmentIdx ).name ) ) then
        declare
           haystack : constant string := to_string( identifiers(assignmentIdx ).name );
           haystack_cstr : aliased char_array :=  To_C( haystack );
        begin
           if needle = haystack( 1..integer( needleLen ) ) then
              if not identifiers( assignmentIdx ).deleted and
                     -- root record, string literal, etc. have spaces
                     -- so users cannot use them.
                       index( identifiers( assignmentIdx ).name, " " ) = 0 and
                     ( identifiers( assignmentIdx ).class = funcClass or
                       identifiers( assignmentIdx ).class = userFuncClass or
                       identifiers( assignmentIdx ).class = varClass or
                       identifiers( assignmentIdx ).class = typeClass or
                       identifiers( assignmentIdx ).class = subClass or
                       identifiers( assignmentIdx ).class = enumClass ) then
                       -- many reserved words do not apply.  those that do
                       -- are often very short.
                       --assignmentIdx <= reserved_top ) then
                return C_strdup( To_Chars_Ptr( haystack_cstr'unchecked_access ) );
              end if;
           end if;
        end;
     end if;
     assignmentIdx := assignmentIdx  - 1;
  end loop;

  -- Return a C NULL pointer to indicate there are no more possibilities.

  return Null_Ptr;
end Ada_assignment_word_generator;


-----------------------------------------------------------------------------
--  FIRST WORD GENERATOR (C language callback to Ada)
--
-- Return candidate words for first word substitutions from the symbol table.
-----------------------------------------------------------------------------

identifierIdx : identifier := identifiers'last;

function Ada_first_word_generator(text : chars_ptr; state : int ) return chars_ptr is
  needle    : constant string := To_Ada( Value( text ) );
  needleLen : constant size_t := Strlen( text );
begin
  -- If this is a new search, move the cursor to the front of the reserved
  -- words.  Otherwise, continue advancing through the list.

  if state = 0 then
     identifierIdx := identifiers'last;
  elsif identifierIdx > identifiers'first then
     -- Note: walks everything, even things not visible.  Perhaps not a big
     -- concern on the command line?
     identifierIdx := identifierIdx  - 1;
  end if;

  -- From the current position in the list, if the text matches the leading
  -- characters of the candidate word, then return the candidate word to C.
  -- Use strdup() to create a new C string which will be deallocated by
  -- GNU readline.

  while identifierIdx > identifiers'first loop
     if needleLen <= size_t( length( identifiers( identifierIdx ).name ) ) then
        declare
           haystack : constant string := to_string( identifiers(identifierIdx ).name );
           haystack_cstr : aliased char_array :=  To_C( haystack );
        begin
           if needle = haystack( 1..integer( needleLen ) ) then
              if not identifiers( identifierIdx ).deleted and
                     -- root record, string literal, etc. have spaces
                     -- so users cannot use them.
                       index( identifiers( identifierIdx ).name, " " ) = 0 and
                     ( identifiers( identifierIdx ).class = procClass or
                       identifiers( identifierIdx ).class = userProcClass or
                       identifiers( identifierIdx ).class = varclass or
                       identifierIdx <= reserved_top ) then
                return C_strdup( To_Chars_Ptr( haystack_cstr'unchecked_access ) );
              end if;
           end if;
        end;
     end if;
     identifierIdx := identifierIdx  - 1;
  end loop;

  -- If there are no more reserved words, return a C NULL pointer to indicate
  -- there are no more possibilities.

  return Null_Ptr;
end Ada_first_word_generator;


-----------------------------------------------------------------------------
--  COMMAND WORD GENERATOR (C language callback to Ada)
--
-- Return candidate commands for first word substitutions from PATH dirs.
-----------------------------------------------------------------------------

remainingCmdPathDirs : unbounded_string;
-- the remaining directories the PATH string

currentCmdPathDir    : unbounded_string;
-- the current directory from the PATH string

currentCmdDir        : dir_type;
-- the directory file type for commands, referring to currentCmdPathDir

function Ada_command_word_generator(text : chars_ptr; state : int ) return chars_ptr is
  path_id : identifier;
  completionFileLen : integer;
  completionFile : string(1..1024); -- TODO: file length limit
  needle    : constant string := To_Ada( Value( text ) );
  needleLen : constant size_t := Strlen( text );
  firstColon : natural;
begin
  if state = 0 then
     findIdent( to_unbounded_string( "PATH" ), path_id );
     if path_id /= eof_t then
        remainingCmdPathDirs := identifiers( path_id ).value.all;
     else
        remainingCmdPathDirs := null_unbounded_string;
     end if;
  end if;

  -- Search the remaining PATH values for a valid directory.
  -- Open that directory.

  while is_open( currentCmdDir ) or remainingCmdPathDirs /= null_unbounded_string loop

     -- If we have an open directory, find a suitable file for substitution.
     -- Read files from the directory.  If a file is found and it matches
     -- the text and is executable, return it as a completion candidate.
     -- Ignore errors.  Continue until an empty string is returned.

     if is_open( currentCmdDir ) then
        loop
           begin
             read( currentCmdDir, completionFile, completionFileLen );
             exit when completionFileLen <= 0;
             if needle = completionFile( 1..integer( needleLen ) ) then
                declare
                   completionFileAsC : aliased char_array := To_C(
                      completionFile(1..completionFileLen ) );
                   testpath : constant string := to_string( currentCmdPathDir ) & directory_delimiter & completionFile(1..completionFileLen) & ASCII.NUL;
                begin
-- TODO: messy.  too many string conversions
-- TODO: does not follow links
                   if C_is_executable( testpath ) then
                      return C_strdup( To_Chars_Ptr( completionFileAsC'unchecked_access ) );
                   end if;
                end;
             end if;
           exception when DIRECTORY_ERROR =>
             null;
           when others =>
             put_line( current_error, gnat.source_info.source_location & ": internal error: unexcepted exception on tab completion" );
           end;
        end loop;
     end if;

     -- Search for a new directory.  Remove paths from the PATH
     -- variable.  Try to open the directory.  If you cannot open
     -- the directory, try the next directory.  Stop searching
     -- when a directory is found or When no paths remain.

     loop
        firstColon := index( remainingCmdPathDirs, ":" );
        if firstColon /= 0 then
           currentCmdPathDir := head( remainingCmdPathDirs, firstColon-1 );
           remainingCmdPathDirs := unbounded_slice( remainingCmdPathDirs, firstColon+1, length( remainingCmdPathDirs ) );
        else
           currentCmdPathDir := remainingCmdPathDirs;
           remainingCmdPathDirs := null_unbounded_string;
        end if;
        begin
          if is_open( currentCmdDir ) then
             close( currentCmdDir );
          end if;
          open( currentCmdDir, to_string( currentCmdPathDir ) );
          exit;
        exception when DIRECTORY_ERROR =>
          null;
        when others =>
          put_line( current_error, gnat.source_info.source_location & ": internal error: unexcepted exception on tab completion" );
        end;
     exit when remainingCmdPathDirs = null_unbounded_string;
     end loop;

  end loop;

  -- Close off the directory search.  Initiate the identifier search.

  if is_open( currentCmdDir ) then
     close( currentCmdDir );
  end if;

  return Null_Ptr;

end Ada_command_word_generator;


-----------------------------------------------------------------------------
--  FILE WORD GENERATOR (C language callback to Ada)
--
-- Return candidate commands for subsequent word substitutions.
-----------------------------------------------------------------------------

currentFileDir : dir_type;

function Ada_file_word_generator(text : chars_ptr; state : int ) return chars_ptr is
  completionFileLen : integer;
  completionFile : string(1..1024);
  needle    : constant string := To_Ada( Value( text ) );
  needleLen : constant size_t := Strlen( text );
begin
  if state = 0 then
     begin
       if is_open( currentFileDir ) then
          close( currentFileDir );
       end if;
       open( currentFileDir, Dir_Name( needle ) );
     exception when DIRECTORY_ERROR =>
       null;
     when others =>
       put_line( current_error, gnat.source_info.source_location & ": internal error: unexcepted exception on tab completion" );
       null;
     end;
  end if;

  -- Search the remaining PATH values for a valid directory.
  -- Open that directory.

  if is_open( currentFileDir ) then

     -- If we have an open directory, find a suitable file for substitution.
     -- Read files from the directory.  If a file is found and it matches
     -- the text and is executable, return it as a completion candidate.
     -- Ignore errors.  Continue until an empty string is returned.

     loop
        begin
          read( currentFileDir, completionFile, completionFileLen );
          exit when completionFileLen <= 0;
          if needle = completionFile( 1..integer( needleLen ) ) then
             declare
                completionFileAsC : aliased char_array := To_C(
                   completionFile(1..completionFileLen ) );
                --testpath : constant string := to_string( currentPathDir ) & directory_delimiter & completionFile(1..completionFileLen) & ASCII.NUL;
             begin
-- TODO: messy.  too many string conversions
-- TODO: does not follow links
                return C_strdup( To_Chars_Ptr( completionFileAsC'unchecked_access ) );
             end;
          end if;
        exception when DIRECTORY_ERROR =>
          null;
        when others =>
          put_line( current_error, gnat.source_info.source_location & ": internal error: unexcepted exception on tab completion" );
        end;
     end loop;

     -- Search for a new directory.  Remove paths from the PATH
     -- variable.  Try to open the directory.  If you cannot open
     -- the directory, try the next directory.  Stop searching
     -- when a directory is found or When no paths remain.


  end if;

  -- Close off the directory search.  Initiate the identifier search.

  if is_open( currentFileDir ) then
     close( currentFileDir );
  end if;

  return Null_Ptr;

end Ada_file_word_generator;


-----------------------------------------------------------------------------
--  EXECUTABLE WORD GENERATOR (C language callback to Ada)
--
-- Chains together all callbacks for the first word on a line.
-----------------------------------------------------------------------------

type executableStages is (commands, idents);
executableStage : executableStages;

function Ada_executable_word_generator(text : chars_ptr; state : int ) return chars_ptr is
  localState : int := state;
  res : chars_ptr;
begin
  -- Just starting?  We're doing commands.

  if state = 0 then
     executableStage := commands;
  end if;

  -- Do command completions.  If we're done, switch to identifiers.
  -- Remember to set state to 0 (just starting).

  if executableStage = commands then
     res := Ada_command_word_generator(text, localState );
     if res = Null_Ptr then
        executableStage := idents;
        localState := 0;
     end if;
  end if;

  -- Do first completions

  if executableStage = idents then
     res := Ada_first_word_generator(text, localState );
  end if;

  return res;
end Ada_executable_word_generator;


-----------------------------------------------------------------------------
--  PARAMETER WORD GENERATOR (C language callback to Ada)
--
-- Chains together all callbacks for the additional words on a line.
-----------------------------------------------------------------------------

type parameterStages is (files, idents);
parameterStage : parameterStages;

function Ada_parameter_word_generator(text : chars_ptr; state : int ) return chars_ptr is
  localState : int := state;
  res : chars_ptr;
begin
  -- Just starting?  We're doing commands.
  if state = 0 then
     parameterStage := files;
  end if;

  -- Do command completions.  If we're done, switch to identifiers.
  -- Remember to set state to 0 (just starting).

  if parameterStage = files then
     res := Ada_file_word_generator(text, localState );
     if res = Null_Ptr then
        parameterStage := idents;
        localState := 0;
     end if;
  end if;

  -- Do identifier completions

  if parameterStage = idents then
     res := Ada_assignment_word_generator(text, localState );
  end if;

  return res;
end Ada_parameter_word_generator;
#end if;

#if READLINE
-----------------------------------------------------------------------------
--  GET LINE
--
-- Read a command line.  Set the terminal to the current TERM variable.
-- Use GNU Readline library to read a line of text, performing any
-- command completions.
--   Exception: raises READLINE_EOF if end-of-file is encountered.
-----------------------------------------------------------------------------
-- TODO: prompt

procedure getLine( line : out unbounded_string;
                   prompt : unbounded_string := null_unbounded_string;
                   keepHistory : boolean := false ) is
  pwd_id  : identifier;
  term_id : identifier;
  termEmu : chars_ptr;
  buffer  : chars_ptr := Null_Ptr;
  bold_prompt : unbounded_string;
begin
  findIdent( to_unbounded_string( "TERM" ), term_id );
  if term_id /= eof_t then
     termEmu := New_String( to_string( identifiers( term_id ).value.all ));
  else
     termEmu := New_String( "xterm" );
  end if;

  if prompt /= null_unbounded_string then
     bold_prompt := prompt;
  else
     -- by default
     -- [# 1][# 27][1m[# 2]=> [# 1][# 27](B[# 27][m[# 2]
     bold_prompt :=
        RL_PROMPT_START_IGNORE &
        term( bold ) &
        RL_PROMPT_END_IGNORE &
        to_string( defaultPrompt ) &
        RL_PROMPT_START_IGNORE &
        term( normal ) &
        RL_PROMPT_END_IGNORE;
  end if;

  declare
     cprompt: constant char_array := To_C( to_string( bold_prompt ) );
  begin
     C_readline( Value( termEmu ), cprompt, buffer );
     if buffer = Null_Ptr then
        if keepHistory then  -- nothing at prompt?
           line := to_unbounded_string( "return" ); -- treat as "return"
           -- TODO: this is a bit of a hack, simulating the line of input.
           -- may be done better?
           new_line;
           --put( line );
           return;
        end if;
     end if;
  end;

  line := to_unbounded_string( Value( buffer ) );

  -- Deallocate C's string buffer once Ada has captured the string.

  C_free_readline( buffer );

  interfaces.c.strings.free( termEmu );

  -- history

  if length( line ) > 0 and keepHistory then -- don't save empty
     history( historyNext ).line := line;           -- lines
     findIdent( to_unbounded_string( "PWD" ), pwd_id ); -- TODO: SLOW!
     if pwd_t /= eof_t then
        history( historyNext ).pwd:= identifiers( pwd_id ).value.all;
     end if;
     history( historyNext ).time := Ada.Calendar.Clock; -- time
     historyNext := historyNext + 1;
     if historyNext > historyArray'last then
        historyNext := 1;
     end if;
  end if;

end getLine;
#else

procedure getLine( line : out unbounded_string; prompt : unbounded_string := null_unbounded_string; keepHistory : boolean := false ) is
   pwd_id : identifier;
-- read a line from the keyboard
-- Note: the keymap is hard-coded, but really should be taken from
-- current terminal settings.


  procedure redrawLine( oldPos : natural; newPos : natural := 0 ) is
  -- redraw the command line
    oldLines  : integer; -- number of lines of old text
    oldChars  : integer; -- number of characters from margin
  begin
    -- these two formulas are not quite right
    -- oldChars and oldLines are the coordinates of the cursor
    if keepHistory then
       -- if keepHistory, then we're at the command line
       --oldLines := ( getPromptIndent+oldPos ) /
       --   integer( displayInfo.col ) + getPromptExtraLines;
       oldLines := ( getPromptIndent+oldPos-2 ) /
          integer( displayInfo.col ) + getPromptExtraLines+1;
       oldChars  := (getPromptIndent + oldPos) -
          ( ( oldLines-1-getPromptExtraLines) * integer( displayInfo.col ) );
    else
       -- otherwise in the get_line function or someplace w/out a prompt
       oldLines := (oldPos-1) / integer( displayInfo.col )+1;
       oldChars  := oldPos - ( (oldLines-1) * integer( displayInfo.col ) );
    end if;
    -- position at start of old line
    for i in 1..oldChars-1 loop
        put( ASCII.BS );
    end loop;
    for i in 1..oldLines-1 loop
        put( term( cleol ) );
        put( term( up ) );
    end loop;
    -- draw new line
    if keepHistory then
       put( bold( to_string( prompt ) ) );
    end if;
    put( line );
    -- the final character on the bottom-right of the screen has special
    -- properties (ie. it triggers the scrolling).  We need to compensate
    -- or the final character won't appear.  If we don't scroll the screen
    -- by writing another character, the final character of the line won't
    -- be displayed!
    if getPromptIndent + length( line ) = 80 then
       put( ' ' );
       put( ASCII.BS );
    end if;
    put( term( cleol ) );
    -- reposition cursor, if desired
    if newPos > 0 then
       for i in newPos..length( line ) loop   -- reposition cursor
           put( ASCII.BS );                   -- (not very efficient)
       end loop;
    end if;
    --put( " - " );
    --put( oldchars'img );
    --put( displayInfo.col'img );
  end redrawLine;

  --  IS DIRECTORY (no readline library)
  --
  -- A quick and simple function to check to see if string dir refers
  -- to a directory.
  ---------------------------------------------------------------------------

  function isDirectory( dir : unbounded_string ) return boolean is
     f : dir_type;
     result : boolean := true;
  begin
    begin
    GNAT.Directory_Operations.Open( f, to_string( dir ) );
    GNAT.Directory_Operations.Close( f );
    -- TODO: should do a stat() probably more efficient
    exception when others => result := false;
    end;
    return result;
  end isDirectory;

  --- SLASHIFY PATH (no readline library)
  --
  -- Add a trailing character for a path.  If a directory, add a trailing /.
  -- If a file, add a trailing space.  If both, add nothing.
  -----------------------------------------------------------------------------

  function slashifyPath( dir, path : unbounded_string ) return string is
    f  : file_type;
    ch : character := ASCII.NUL;
  begin
    begin
      Ada.Text_IO.Open( f, in_file, to_string( dir & Dir_Separator & path ) );
      Ada.Text_IO.Close( f );
      if isDirectory( dir & Dir_Separator & path ) then
         ch := Dir_Separator;
      else
         ch := ' ';
      end if;
    exception when others => null;
    end;
    if ch /= ASCII.NUL then
       return "" & ch;
    end if;
    return "";
  end slashifyPath;

  --- COMPLETE PATHANME (no readline library)
  --
  ---------------------------------------------------------------------------

  procedure completePathname( dir : unbounded_string;
    s : unbounded_string;
    result : out unbounded_string;
    list : boolean := false ) is
    globCriteria : regexp;
    count        : natural := 0;
    dir2test     : Dir_Type;
    fileName     : string(1..256);
    fileNameLen  : natural;
    noPWD        : boolean := false;
    bestCommon   : unbounded_string; -- longest common part
    listCount    : natural := 0;
    isListing    : boolean := list;
    expandedDir  : unbounded_string;
    home_id      : identifier;
  begin
    -- Show a list of possible matches? Move down a line.
    if isListing then
       New_Line;
       put( term( cleop ) );
    end if;
    -- A tilde?  Then substitute in the home directory.
    if length( dir ) > 0 and then element( dir, 1) = '~' then
       findIdent( to_unbounded_string( "HOME" ), home_id );
       expandedDir := identifiers( home_id ).value.all & slice( dir, 2, length(dir));
    else
       expandedDir := dir;
    end if;
--put_line( "EXPANDED DIR = '" & dir & "' => " & expandedDir & "'+'" & s & "'" ); -- DEBUG
    bestCommon   := null_unbounded_string;
    globCriteria := Compile( to_string( s ), Glob => true,
       Case_Sensitive => true );
    begin
       open( dir2test, to_string( expandedDir ) );
    exception when others =>
      noPWD := true;
    end;
    if noPWD then
       simpleBeep;
       result := null_unbounded_string;
       return;
    end if;
    -- KB: 12/02/18 - gcc dir ops changes, no longer returns "." but we'll
    -- check below to be safe.
    --read( dir2test, fileName, fileNameLen ); -- skip "."
    --read( dir2test, fileName, fileNameLen ); -- skip ".."
    loop
      read( dir2test, fileName, fileNameLen );
      exit when fileNameLen = 0;
      if fileName( 1..fileNameLen ) = "." then
         null;
      elsif fileName( 1..fileNameLen ) = ".." then
         null;
      elsif Match( fileName(1..fileNameLen ) , globCriteria ) then
         count := count + 1;
         if isListing then
            put_line( fileName(1..fileNameLen) & slashifyPath( dir, to_unbounded_string( fileName(1..fileNameLen) ) ) );
            listCount := listCount + 1;
            isListing := listCount /= 10; -- no more than 10
            if not isListing then
               put_line( optional_bold( "[Maybe More]" ) );
            end if;
         end if;
         if count = 1 then
            result := to_unbounded_string( fileName( 1..fileNameLen ) );
            bestCommon := result;
         else
            -- more than 1 hit? trim bestCommon start to fit the
            -- result.  If bestCommon is null, no common starting
            -- characters.
            for i in 1..fileNameLen loop
                exit when i > length( bestCommon );
                if i = fileNameLen then
                   bestCommon := head( bestCommon, i-1 );
                elsif element( bestcommon, i ) /= fileName(i) then
                   if i = 1 then
                      bestCommon := null_unbounded_string;
                   else
                      bestCommon := head( bestCommon, i-1 );
                   end if;
                end if;
            end loop;
         end if;
      end if;
    end loop;
    close( dir2test );
    if count > 1 then
       simpleBeep;
       result := bestCommon;
    elsif count = 0 then
       simpleBeep;
       result := null_unbounded_string;
    end if;
  end completePathname;

  --- LAST WORD (no readline library)
  --
  -- remove the last "word" delinated by a space from the string
  -- return the ending character of the rest of the string
  ---------------------------------------------------------------------------

  procedure lastWord( s : unbounded_string; lw : out unbounded_string;
    lp : out natural ) is
  begin
    lp := 0;
    for i in reverse 1..length( s )-1 loop
        if element( s, i ) = ' ' then
           lp := i;
           exit;
        end if;
    end loop;
    lw := to_unbounded_string( slice( s,  lp+1, length( s ) ) );
  end lastWord;

  vi_escape    : boolean := false; -- true if expecting vi-mode command
  arrow_escape : boolean := false; -- true if expecting VT-100 arrow
  last_was_esc : boolean := false; -- true if last char was ESC
  last_was_esc_o : boolean := false; -- true if last chars were ESC+O
  last_was_esc_sq_3 : boolean := false; -- true if last chars were ESC+[+3
  ch         : character; -- last character read
  pos        : natural;   -- position to insert next character
  old_pos    : natural;   -- for redrawing lines
  histpos    : integer;   -- position in history
  crit_pos   : natural;   -- for searching history
  criteria   : unbounded_string;
  justCompleted : boolean := false;
begin

  -- if a prompt, show it in bold first
  if length( prompt ) > 0 then
     put( bold( to_string( prompt ) ) );
  end if;

  line     := null_unbounded_string;
  criteria := null_unbounded_string;
  pos      := 1;
  histpos  := historyNext;

  loop
<<retry>> getKey( ch );
    if wasSIGINT then                   -- if SIGINT raised
       return;                          -- let caller determine what to do
    end if;

    -- VI ESCAPE MODE HANDLING
    --
    -- process sequence and convert to its emacs mode equivalent

    if ch = ASCII.ESC then
       if last_was_esc then             -- two escapes?
          ch := ASCII.HT;               -- cmdline completion
          last_was_esc := false;        -- cancel vi mode
          vi_escape := false;           -- exit vi escape
       else                             -- first escape?
          vi_escape := not vi_escape;   -- enter/exit vi escape mode
          if vi_escape then
             last_was_esc := true;         -- remember in case double esc
          end if;
          goto retry;                   -- and go get next key
       end if;
    elsif arrow_escape then                   -- ESC + [ + ...?
       last_was_esc := false;
       arrow_escape := false;                 -- got our arrow code
       if ch = 'A' then                       -- A = up
          ch := ASCII.DLE;
       elsif ch = 'B' then                    -- B = down
          ch := ASCII.SO;
       elsif ch = 'C' then                    -- C = right
          ch := ASCII.ACK;
       elsif ch = 'D' then                    -- D = left
          ch := ASCII.STX;
       elsif ch = '3' then                    -- Delete Key
          last_was_esc_sq_3 := true;
          goto retry;
       else
          simpleBeep;                         -- otherwise unknown
       end if;
    elsif last_was_esc_sq_3 then              -- ESC + [ + 3 + ...?
       last_was_esc_sq_3 := false;
       if ch = '~' then                       -- no vi equivalent to DEL key
          ch := ASCII.NAK;                    -- control-u
       end if;
    elsif last_was_esc_o then                 -- ESC + O + ...?
        last_was_esc := false;
        last_was_esc_o := false;
        if ch = 'H' then                      -- home key (ESC+O+H)
           ch := ASCII.SOH;
        elsif ch = 'F' then                   -- end key (ESC+O+F)
           ch := ASCII.ENQ;
        else
           simpleBeep;                        -- otherwise unknown
        end if;
    elsif vi_escape then
       last_was_esc := false;
       if ch ='[' then                        -- same as control-n
          arrow_escape := true;
          vi_escape := false;                 -- cancel vi mode
          goto retry;
       elsif ch ='j' then                     -- same as control-n
          ch := ASCII.SO;
       elsif ch = 'k' then                    -- same as control-p
          ch := ASCII.DLE;
       elsif ch = 'h' then                    -- same as control-b
          ch := ASCII.STX;
       elsif ch = 'l' then                    -- same as control-f
          ch := ASCII.ACK;
       elsif ch = '^' then                    -- same as control-a
          ch := ASCII.SOH;
       elsif ch = '$' then                    -- same as control-e
          ch := ASCII.ENQ;
       elsif ch = 'x' then                    -- same as control-u
          ch := ASCII.NAK;
       elsif ch = 'O' then                    -- home/end keys
          last_was_esc_o := true;             -- ESC+O
          vi_escape := false;                 -- cancel vi mode
          goto retry;
       else                                   -- else not supported
          vi_escape := false;                 -- drop out of vi escape mode
          simpleBeep;                         -- beep at illegal character
          goto retry;                         -- and get next key
       end if;
    elsif ch = ASCII.EOT then                 -- control-d / end of file?
       if length( line ) = 0 and keepHistory then  -- nothing at prompt?
          line := to_unbounded_string( "return" ); -- treat as "return"
          pos := 5;
          put( line );
       end if;                                -- otherwise
       ch := ASCII.CR;                        -- treat as end of input
    end if;

    if ch /= ASCII.HT then
       justCompleted := false;
    end if;

    -- EMACS MODE HANDLING

    case ch is
    when ASCII.HT =>                         -- TAB = pathname completion
       declare
          path : unbounded_string;
          dir  : unbounded_string;
          file : unbounded_string;
          lp   : natural;
          listFiles : boolean := false;
       begin
          if justCompleted then
             listFiles := true;
          else
             justCompleted := true;
          end if;
          lastWord( line, path, lp );
          if length( path ) = 0 then
             simpleBeep;
             goto retry;
          end if;
          -- as a special case, if the path is the name of a directory,
          -- just add a slash and redraw the line (bash works this way)
          -- I set justCompleted to false to be in line with bash's
          -- behaviour. ('ls .' , you have to hit tab 3 times to get list)
          if element( path, length( path ) ) /= Dir_Separator then
             if isDirectory( path ) then
                line := line & Dir_Separator;
                justCompleted := false;
                goto redraw;
             end if;
          end if;
          -- for path x/y, dir = x and y = file
          -- for path x/, dir = x and basename file = . (i.e. itself)
          dir  := dirname( path );
          -- we don't want .* in this case, just * unless the user
          -- specifically adds a /.
          if element( path, length( path ) ) /= Dir_Separator then
             file := basename( path );
          else
             file := null_unbounded_string;
          end if;
          file := file & "*";
--put_line( "BREAKDOWN = '" & path & "' => " & dir & "'+'" & file & "'" ); -- DEBUG
          if listFiles then
             completePathname( dir, file, path, list => true );
          else
             completePathname( dir, file, path );
          end if;
          if length( path ) > 0 then
             if to_string( dir ) = "." then
                line := slice( line, 1, lp ) & path;
             else
                line := slice( line, 1, lp ) & dir & Dir_Separator & path;
             end if;
             declare
                -- if a file, add a ' '.
                f : file_type;
             begin
                Ada.Text_IO.Open( f, in_file, to_string( dir & Dir_Separator & path ) );
                Ada.Text_IO.Close( f );
                -- should do a stat()
                declare
                   -- if a dir, add a '/'
                   f : dir_type;
                begin
                   GNAT.Directory_Operations.Open( f, to_string( dir & Dir_Separator & path ) );
                   GNAT.Directory_Operations.Close( f );
                   -- TODO: should do a stat()
                   line := line & Dir_Separator;
                exception when others =>
                   line := line & " ";
                end;
             exception when others => null;
             end;
          end if;
<<redraw>>old_pos := pos;                     -- remember old position
          pos := length( line ) + 1;          -- new position at end
          redrawLine( old_pos, pos );
       end;
    when ASCII.CR | ASCII.LF =>
       new_line;
       if length( line ) > 0 and keepHistory then -- don't save empty
          history( historyNext ).line := line;           -- lines
          findIdent( to_unbounded_string( "PWD" ), pwd_id ); -- TODO: SLOW!
          if pwd_t /= eof_t then
             history( historyNext ).pwd:= identifiers( pwd_id ).value.all;
          end if;
          history( historyNext ).time := Ada.Calendar.Clock; -- time
          historyNext := historyNext + 1;
          if historyNext > historyArray'last then
             historyNext := 1;
          end if;
       end if;
       exit;
    when ASCII.BS | ASCII.DEL =>              -- control-h or delete key
       if pos > 1 then
          delete( line, pos-1, pos-1 );       -- delete char to left of cursor
          old_pos := pos;                     -- remember old position
          pos := pos - 1;                     -- new position is one to left
          redrawLine( old_pos, pos );         -- redraw line, cursor at end
       else                                   -- nothing to delete?
          simpleBeep;                         -- beep
       end if;
    when ASCII.NAK =>                         -- control-u or del key
       if length( line ) > 0 then
          old_pos := pos;                     -- remember old position
          if pos > length( line ) then        -- beyond eol?
             pos := pos - 1;                  -- position one to left
          elsif pos = length( line ) then     -- was at last char?
             delete( line, pos, pos );        -- delete char under cursor
             if pos /= 1 then                 -- if last char, don't move
                pos := pos - 1;               -- position is one to left
             end if;
          else                                -- else
             delete( line, pos, pos );        -- delete char under cursor
          end if;                             -- and don't move
          redrawLine( old_pos, pos );         -- redraw line
       else                                   -- nothing to delete?
          simpleBeep;                         -- beep
       end if;
    when ASCII.STX =>                         -- control-b
       if pos > 1 then
          old_pos := pos;                     -- remember old position
          pos := pos - 1;                     -- new position is one to left
          put( ASCII.BS );                    -- move cursor
       else                                   -- no place to go?
          simpleBeep;                         -- beep
       end if;
    when ASCII.ACK =>                         -- control-f
          if pos <= length( line ) then
             old_pos := pos;                  -- remember old position
             pos := pos + 1;                  -- new position is one to right
             put( term( right ) );            -- move cursor
          else                                -- no place to go?
             simpleBeep;                      -- beep
          end if;
    when ASCII.SO =>                          -- control-n
      if histpos = historyNext or not keepHistory then
         simpleBeep;
      else
         histpos := histpos + 1;
         if histpos > historyArray'last then
            histpos := 1;
         end if;
         old_pos := pos;                     -- remember old position
         line := history( histpos ).line;
         pos := length( line ) + 1;          -- new position at end of string
         redrawLine( old_pos, pos );         -- redraw line, cursor at end
      end if;
    when ASCII.DLE =>                         -- control-p
      if not keepHistory then
         simpleBeep;
      else
         old_pos := histpos;
         histpos := histpos - 1;
         if histpos < 1 then
            histpos := historyArray'last;
         end if;
         if histpos = historyNext then
            histpos := old_pos;
            simpleBeep;
         else
            old_pos := pos;                     -- remember old position
            line := history( histpos ).line;
            pos := length( line ) + 1;          -- new position at end of string
            redrawLine( old_pos, pos );         -- redraw line, cursor at end
         end if;
      end if;
    when ASCII.CAN =>                     -- control-x/c
      old_pos := pos;                     -- remember old position
      pos := 1;                           -- empty string now
      line := null_unbounded_string;
      redrawLine( old_pos );              -- redraw line
    when ASCII.SOH =>                     -- control-a
      redrawLine( pos, 1 );
      pos := 1;                           -- fix position
    when ASCII.ENQ =>                     -- control-e
      old_pos := pos;                     -- remember old position
      pos := length( line ) + 1;          -- new position at end of string
      redrawLine( old_pos, pos );         -- redraw line, cursor at end
    when ASCII.DC2 =>                         -- control-r
      if pos = 1 then
         simpleBeep;
         goto retry;
      elsif pos > length( line ) then
         criteria := line;
      else
         criteria := Delete( line, pos, length( line ) );
      end if;
      old_pos := histpos;
      crit_pos := pos;
      loop
        histpos := histpos - 1;
        if histpos < 1 then
           histpos := historyArray'last;
        end if;
        if histpos = historyNext then         -- out of history?
           line := criteria;                  -- restore old line
           histpos := old_pos;                -- that's all folks
           simpleBeep;
           exit;
        end if;
        line := history( histpos ).line;      -- next history line
        if Index( line, To_String( Criteria ) ) = 1 then -- matches criteria?
           pos := length( line ) + 1;         -- new position at end of string
           redrawLine( crit_pos, pos );       -- redraw line, cursor at end
           exit;
        end if;
      end loop;
    when ASCII.GS =>                          -- control-] (forward char search)
      old_pos := pos;
      getKey( ch );
      for i in pos+1..length( line ) loop
          if Element( line, i ) = ch then
             pos := i;
             exit;
          end if;
      end loop;
      if pos = old_pos then
         simpleBeep;
      else
         redrawLine( old_pos, pos );
      end if;
    when others =>
       if pos > length( line ) then           -- adding at end of line?
          line := line & ch;                  -- append character
          pos := pos + 1;                     -- new position is one to right
          put( ch );                          -- display character
       else
          insert( line, pos, ch & "" );       -- insert the character
          old_pos := pos;                     -- remember old position
          pos := pos + 1;                     -- new position is one to right
          redrawLine( old_pos, pos );         -- redraw line, cursor at end
       end if;
    end case;
  end loop;
end getLine;

-- Dummy Functions (not used unless GNU readline)

function Ada_git_word_generator(text : chars_ptr; state : int ) return chars_ptr is
begin
  return Null_Ptr;
end Ada_git_word_generator;

function Ada_executable_word_generator(text : chars_ptr; state : int ) return chars_ptr is
begin
  return Null_Ptr;
end Ada_executable_word_generator;

function Ada_assignment_word_generator(text : chars_ptr; state : int ) return chars_ptr is
begin
  return Null_Ptr;
end Ada_assignment_word_generator;

function Ada_parameter_word_generator(text : chars_ptr; state : int ) return chars_ptr is
begin
  return Null_Ptr;
end Ada_parameter_word_generator;
#end if;


-----------------------------------------------------------------------------
--  HAS READLINE
--
-- TRUE if we are using the GNU readline library.
-----------------------------------------------------------------------------

function has_readline return boolean is
begin
#if READLINE
  return true;
#else
  return false;
#end if;
end has_readline;


-----------------------------------------------------------------------------
--
-- HOUSEKEEPING
--
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
--  STARTUP READLINE
--
-- Startup this package and GNU Readline library, performing any setup
-- tasks.
-----------------------------------------------------------------------------

#if READLINE
procedure startupGetline is

  procedure git_add( s : string ) is
  begin
    completionLists.append( gitWords, New_String( s ) );
    memoryLeakCnt := memoryLeakCnt + 1;
  end git_add;

begin
  C_init_readline;
-- TODO: better options
  git_add("add");
  git_add("add--interactive");
  git_add("am");
  git_add("annotate");
  git_add("apply");
  git_add("archive");
  git_add("bisect");
  git_add("bisect--helper");
  git_add("blame");
  git_add("branch");
  git_add("bundle");
  git_add("cat-file");
  git_add("check-attr");
  git_add("check-ignore");
  git_add("check-mailmap");
  git_add("check-ref-format");
  git_add("checkout");
  git_add("checkout-index");
  git_add("cherry");
  git_add("cherry-pick");
  git_add("clean");
  git_add("clone");
  git_add("column");
  git_add("commit");
  git_add("commit-tree");
  git_add("config");
  git_add("count-objects");
  git_add("credential");
  git_add("credential-cache");
  git_add("credential-cache--daemon");
  git_add("credential-store");
  git_add("daemon");
  git_add("describe");
  git_add("diff");
  git_add("diff-files");
  git_add("diff-index");
  git_add("diff-tree");
  git_add("difftool");
  git_add("difftool--helper");
  git_add("fast-export");
  git_add("fast-import");
  git_add("fetch");
  git_add("fetch-pack");
  git_add("filter-branch");
  git_add("fmt-merge-msg");
  git_add("for-each-ref");
  git_add("format-patch");
  git_add("fsck");
  git_add("fsck-objects");
  git_add("gc");
  git_add("get-tar-commit-id");
  git_add("grep");
  git_add("hash-object");
  git_add("help");
  git_add("http-backend");
  git_add("http-fetch");
  git_add("http-push");
  git_add("imap-send");
  git_add("index-pack");
  git_add("init");
  git_add("init-db");
  git_add("instaweb");
  git_add("interpret-trailers");
  git_add("log");
  git_add("ls-files");
  git_add("ls-remote");
  git_add("ls-tree");
  git_add("mailinfo");
  git_add("mailsplit");
  git_add("merge");
  git_add("merge-base");
  git_add("merge-file");
  git_add("merge-index");
  git_add("merge-octopus");
  git_add("merge-one-file");
  git_add("merge-ours");
  git_add("merge-recursive");
  git_add("merge-resolve");
  git_add("merge-subtree");
  git_add("merge-tree");
  git_add("mergetool");
  git_add("mktag");
  git_add("mktree");
  git_add("mv");
  git_add("name-rev");
  git_add("notes");
  git_add("pack-objects");
  git_add("pack-redundant");
  git_add("pack-refs");
  git_add("patch-id");
  git_add("prune");
  git_add("prune-packed");
  git_add("pull");
  git_add("push");
  git_add("quiltimport");
  git_add("read-tree");
  git_add("rebase");
  git_add("rebase--helper");
  git_add("receive-pack");
  git_add("reflog");
  git_add("remote");
  git_add("remote-ext");
  git_add("remote-fd");
  git_add("remote-ftp");
  git_add("remote-ftps");
  git_add("remote-http");
  git_add("remote-https");
  git_add("remote-testsvn");
  git_add("repack");
  git_add("replace");
  git_add("request-pull");
  git_add("rerere");
  git_add("reset");
  git_add("rev-list");
  git_add("rev-parse");
  git_add("revert");
  git_add("rm");
  git_add("send-pack");
  git_add("sh-i18n--envsubst");
  git_add("shell");
  git_add("shortlog");
  git_add("show");
  git_add("show-branch");
  git_add("show-index");
  git_add("show-ref");
  git_add("submodule");
  git_add("stage");
  git_add("stash");
  git_add("status");
  git_add("stripspace");
  git_add("submodule--helper");
  git_add("subtree");
  git_add("symbolic-ref");
  git_add("tag");
  git_add("unpack-file");
  git_add("unpack-objects");
  git_add("update-index");
  git_add("update-ref");
  git_add("update-server-info");
  git_add("upload-archive");
  git_add("upload-pack");
  git_add("var");
  git_add("verify-commit");
  git_add("verify-pack");
  git_add("verify-tag");
  git_add("web--browse");
  git_add("whatchanged");
  git_add("worktree");
  git_add("write-tree");
end startupGetline;
#else
procedure startupGetline is
begin
  null;
end startupGetline;
#end if;

-----------------------------------------------------------------------------
--  SHUTDOWN READLINE
--
-- Shutdown this package and GNU Readline library, performing any cleanup
-- tasks.
--  Exception: COMPLETION_MEMORY_LEAK is raised if there are C strings
-- that weren't deallocated.
-----------------------------------------------------------------------------

#if READLINE
procedure shutdownGetline is
  wordPtr : chars_ptr;
begin
  for i in completionLists.First_Index( gitWords )..completionLists.Last_Index( gitWords ) loop
      wordPtr := completionLists.Element( gitWords, i );
      Free( wordPtr );
      memoryLeakCnt := memoryLeakCnt - 1;
  end loop;
  if memoryLeakCnt /= 0 then
     raise COMPLETION_MEMORY_LEAK with "items" & memoryLeakCnt'img;
  end if;
end shutdownGetline;
#else
procedure shutdownGetline is
begin
  null;
end shutdownGetline;
#end if;

end user_io.getline;

