------------------------------------------------------------------------------
-- Localization Package Parser                                              --
--                                                                          --
-- Part of SparForte                                                        --
------------------------------------------------------------------------------
--                                                                          --
--            Copyright (C) 2001-2021 Free Software Foundation              --
--                                                                          --
-- This is free software;  you can  redistribute it  and/or modify it under --
-- terms of the  GNU General Public License as published  by the Free Soft- --
-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
-- sion.  This is distributed in the hope that it will be useful, but WITH- --
-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
-- for  more details.  You should have  received  a copy of the GNU General --
-- Public License  distributed with this;  see file COPYING.  If not, write --
-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
-- MA 02111-1307, USA.                                                      --
--                                                                          --
-- This is maintained at http://www.pegasoft.ca                             --
--                                                                          --
------------------------------------------------------------------------------

with ada.strings.unbounded,
#if L10N
     spar_os.l10n,
#end if;
     world,
     scanner,
     parser_params;
use  ada.strings.unbounded,
#if L10N
     spar_os,
     spar_os.l10n,
#end if;
     world,
     scanner,
     parser_params;

package body parser_l10n is

------------------------------------------------------------------------------
-- Localization package identifiers
------------------------------------------------------------------------------

l10n_setlocale_t : identifier;

l10n_codeset_t : identifier;
l10n_d_t_fmt_t : identifier;
l10n_d_fmt_t   : identifier;
l10n_t_fmt_t   : identifier;
l10n_day_t     : identifier;
l10n_abday_t   : identifier;
l10n_mon_t     : identifier;
l10n_abmon_t   : identifier;
l10n_decimal_point_t : identifier;
l10n_thousands_sep_t : identifier;
l10n_yesexpr_t : identifier;
l10n_noexpr_t  : identifier;
l10n_currency_symbol_t: identifier;
l10n_amstr_t   : identifier;
l10n_pmstr_t   : identifier;
l10n_t_fmt_ampm_t : identifier;
l10n_positive_sign_t : identifier;
l10n_negative_sign_t : identifier;
l10n_int_curr_symbol_t : identifier;
l10n_locale_category_t : identifier;
l10n_lc_all_t : identifier;
l10n_lc_collate_t : identifier;
l10n_lc_messages_t : identifier;
l10n_lc_monetary_t : identifier;
l10n_lc_ctype_t : identifier;
l10n_lc_time_t : identifier;


---------------------------------------------------------
--
-- PARSE THE L10N PACKAGE
--
---------------------------------------------------------

#if not L10N
procedure not_configured( result : out unbounded_string; kind : out identifier ) is
begin
  result := null_unbounded_string;
  kind := universal_t;
  err( "l10n support not configured" );
end not_configured;

procedure not_configured is
begin
  err( "l10n support not configured" );
end not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N SETLOCALE
--
-- Syntax: l10n.setlocale;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NSetLocale is
  cat_val : unbounded_string;
  cat_kind :identifier;
  loc_val : unbounded_string;
  loc_kind :identifier;
begin
  expect( l10n_setlocale_t );
  ParseFirstNumericParameter( cat_val, cat_kind );
  ParseLastStringParameter( loc_val,loc_kind );
  if isExecutingCommand then
     C_reset_errno;
     setlocale( locale_type( to_numeric( cat_val ) ), to_string( loc_val ) );
     if C_errno = 0 then
        err( "setlocale error, " & "error #" & C_errno'img );
     end if;
  end if;
end ParseL10NSetLocale;
#else
procedure ParseL10NSetLocale renames not_configured;
#end if;

-----------------------------------------------------------------------------
--  PARSE L10N CODESET
--
-- Syntax: l10n.codeset;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NCodeSet( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_codeset_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := codeset;
end ParseL10NCodeSet;
#else
procedure ParseL10NCodeSet( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;

-----------------------------------------------------------------------------
--  PARSE L10N D T FMT (Date and Time Format)
--
-- Syntax: l10n.d_fmt;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NDTFmt( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_d_t_fmt_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  if isExecutingCommand then
     result := d_t_fmt;
  end if;
end ParseL10NDTFmt;
#else
procedure ParseL10NDTFmt( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N D FMT (Date Format)
--
-- Syntax: l10n.d_fmt;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NDFmt( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_d_fmt_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  if isExecutingCommand then
     result := d_fmt;
  end if;
end ParseL10NDFmt;
#else
procedure ParseL10NDFmt( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;



-----------------------------------------------------------------------------
--  PARSE L10N T FMT (Time Format)
--
-- Syntax: l10n.t_fmt;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NTFmt( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_t_fmt_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  if isExecutingCommand then
     result := t_fmt;
  end if;
end ParseL10NTFmt;
#else
procedure ParseL10NTFmt( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N DAY (Day of Week)
--
-- Syntax: l10n.day( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NDay( result : out unbounded_string; kind : out identifier ) is
  dayExpr : unbounded_string;
  dayKind : identifier;
  day     : positive;
begin
  kind := uni_string_t;
  expect( l10n_day_t );
  ParseSingleNumericParameter( dayExpr, dayKind, positive_t );
  if isExecutingCommand then
     begin
        day := positive( to_numeric( dayExpr ) );
        case day is
        when 1 => result := day_1;
        when 2 => result := day_2;
        when 3 => result := day_3;
        when 4 => result := day_4;
        when 5 => result := day_5;
        when 6 => result := day_6;
        when 7 => result := day_7;
        when others =>
          err( "day is 1..7" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NDay;
#else
procedure ParseL10NDay( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N AB DAY (Abbreviated Day of Week)
--
-- Syntax: l10n.abday( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NAbDay( result : out unbounded_string; kind : out identifier ) is
  dayExpr : unbounded_string;
  dayKind : identifier;
  day     : positive;
begin
  kind := uni_string_t;
  expect( l10n_abday_t );
  ParseSingleNumericParameter( dayExpr, dayKind, positive_t );
  if isExecutingCommand then
     begin
        day := positive( to_numeric( dayExpr ) );
        case day is
        when 1 => result := abday_1;
        when 2 => result := abday_2;
        when 3 => result := abday_3;
        when 4 => result := abday_4;
        when 5 => result := abday_5;
        when 6 => result := abday_6;
        when 7 => result := abday_7;
        when others =>
          err( "day is 1..7" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NAbDay;
#else
procedure ParseL10NAbDay( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N MON (Month)
--
-- Syntax: l10n.mon( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NMon( result : out unbounded_string; kind : out identifier ) is
  monExpr : unbounded_string;
  monKind : identifier;
  mon     : positive;
begin
  kind := uni_string_t;
  expect( l10n_mon_t );
  ParseSingleNumericParameter( monExpr, monKind, positive_t );
  if isExecutingCommand then
     begin
        mon := positive( to_numeric( monExpr ) );
        case mon is
        when 1 => result := mon_1;
        when 2 => result := mon_2;
        when 3 => result := mon_3;
        when 4 => result := mon_4;
        when 5 => result := mon_5;
        when 6 => result := mon_6;
        when 7 => result := mon_7;
        when 8 => result := mon_8;
        when 9 => result := mon_9;
        when 10 => result := mon_10;
        when 11 => result := mon_11;
        when 12 => result := mon_12;
        when others =>
          err( "month is 1..12" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NMon;
#else
procedure ParseL10NMon( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N AB MON (Abbreviated Month)
--
-- Syntax: l10n.abmon( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NAbMon( result : out unbounded_string; kind : out identifier ) is
  monExpr : unbounded_string;
  monKind : identifier;
  mon     : positive;
begin
  kind := uni_string_t;
  expect( l10n_abmon_t );
  ParseSingleNumericParameter( monExpr, monKind, positive_t );
  if isExecutingCommand then
     begin
        mon := positive( to_numeric( monExpr ) );
        case mon is
        when 1 => result := abmon_1;
        when 2 => result := abmon_2;
        when 3 => result := abmon_3;
        when 4 => result := abmon_4;
        when 5 => result := abmon_5;
        when 6 => result := abmon_6;
        when 7 => result := abmon_7;
        when 8 => result := abmon_8;
        when 9 => result := abmon_9;
        when 10 => result := abmon_10;
        when 11 => result := abmon_11;
        when 12 => result := abmon_12;
        when others =>
          err( "month is 1..12" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NAbMon;
#else
procedure ParseL10NAbMon( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N DECIMAL POINT
--
-- Syntax: l10n.decimal_point;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NDecimalPoint( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_decimal_point_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := decimal_point;
end ParseL10NDecimalPoint;
#else
procedure ParseL10NDecimalPoint( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N THOUSANDS SEP (Thousands Separator)
--
-- Syntax: l10n.thousep;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NThousandsSep( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_thousands_sep_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := thousands_sep;
end ParseL10NThousandsSep;
#else
procedure ParseL10NThousandsSep( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N YES EXPR (Yes Expression)
--
-- Syntax: l10n.yesexpr;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NYesExpr( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_yesexpr_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := yesexpr;
end ParseL10NYesExpr;
#else
procedure ParseL10NYesExpr( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N NO EXPR (No Expression)
--
-- Syntax: l10n.noexpr;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NNoExpr( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_noexpr_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := noexpr;
end ParseL10NNoExpr;
#else
procedure ParseL10NNoExpr( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N CURRENCY SYMBOL
--
-- Syntax: l10n.currency_symbol
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NCurrencySymbol( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_currency_symbol_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := currency_symbol;
end ParseL10NCurrencySymbol;
#else
procedure ParseL10NcurrencySymbol( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N AM STR
--
-- Syntax: l10n.amstr;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NAmStr( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_amstr_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := amstr;
end ParseL10NAmStr;
#else
procedure ParseL10NAmStr( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N PM STR
--
-- Syntax: l10n.pmstr;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NPmStr( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_pmstr_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := pmstr;
end ParseL10NPmStr;
#else
procedure ParseL10NPmStr( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N T FMT AM PM
--
-- Syntax: l10n.fmt_ampm
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NTFmtAmPm( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_t_fmt_ampm_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := pmstr;
end ParseL10NTFmtAmPm;
#else
procedure ParseL10NTFmtAmPm( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N POSITIVE SIGN
--
-- Syntax: l10n.positive_sign
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NPositiveSign( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_positive_sign_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := positive_sign;
end ParseL10NPositiveSign;
#else
procedure ParseL10NPositiveSign( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N NEGATIVE SIGN
--
-- Syntax: l10n.negative_sign
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NNegativeSign( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_negative_sign_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := negative_sign;
end ParseL10NNegativeSign;
#else
procedure ParseL10NNegativeSign( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N INT CURR SYMBOL
--
-- Syntax: l10n.int_curr_symbol
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NIntCurrSymbol( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_int_curr_symbol_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := negative_sign;
end ParseL10NIntCurrSymbol;
#else
procedure ParseL10NIntCurrSymbol( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-------------------------------------------------------------------------------
--
-- Housekeeping
--
-------------------------------------------------------------------------------


procedure StartupL10N is
begin
  declareNamespace( "l10n" );

  declareProcedure( l10n_setlocale_t, "l10n.setlocale", ParseL10NSetLocale'access );

  declareFunction( l10n_codeset_t, "l10n.codeset", ParseL10NCodeSet'access );
  declareFunction( l10n_d_t_fmt_t, "l10n.d_t_fmt", ParseL10NDTFmt'access );
  declareFunction( l10n_d_fmt_t, "l10n.d_fmt", ParseL10NDFmt'access );
  declareFunction( l10n_t_fmt_t, "l10n.t_fmt", ParseL10NTFmt'access );
  declareFunction( l10n_day_t, "l10n.day", ParseL10NDay'access );
  declareFunction( l10n_abday_t, "l10n.abday", ParseL10NAbDay'access );
  declareFunction( l10n_mon_t, "l10n.mon", ParseL10NMon'access );
  declareFunction( l10n_abmon_t, "l10n.abmon", ParseL10NAbMon'access );
  declareFunction( l10n_decimal_point_t, "l10n.decimal_point", ParseL10NDecimalPoint'access );
  declareFunction( l10n_thousands_sep_t, "l10n.thousands_sep", ParseL10NThousandsSep'access );
  declareFunction( l10n_yesexpr_t, "l10n.yesexpr", ParseL10NYesExpr'access );
  declareFunction( l10n_noexpr_t, "l10n.noexpr", ParseL10NNoExpr'access );
  declareFunction( l10n_currency_symbol_t, "l10n.currency_symbol", ParseL10NCurrencySymbol'access );
  declareFunction( l10n_amstr_t, "l10n.amstr", ParseL10NAMStr'access );
  declareFunction( l10n_pmstr_t, "l10n.pmstr", ParseL10NPMStr'access );
  declareFunction( l10n_t_fmt_ampm_t, "l10n.t_fmt_ampm", ParseL10NTFmtAmPm'access );
  declareFunction( l10n_positive_sign_t, "l10n.positive_sign", ParseL10NPositiveSign'access );
  declareFunction( l10n_negative_sign_t, "l10n.negative_sign", ParseL10NNegativeSign'access );
  declareFunction( l10n_int_curr_symbol_t, "l10n.int_curr_symbol", ParseL10NIntCurrSymbol'access );

  declareIdent( l10n_locale_category_t, "l10n.locale_category", integer_t, typeClass );

  declareStandardConstant( l10n_lc_all_t, "l10n.lc_all", l10n_locale_category_t,
LC_ALL'img );
  declareStandardConstant( l10n_lc_collate_t, "l10n.lc_collate", l10n_locale_category_t, LC_COLLATE'img );
  declareStandardConstant( l10n_lc_messages_t, "l10n.lc_messages", l10n_locale_category_t, LC_MESSAGES'img );
  declareStandardConstant( l10n_lc_monetary_t, "l10n.lc_monetary", l10n_locale_category_t, LC_MONETARY'img );
  declareStandardConstant( l10n_lc_ctype_t, "l10n.lc_ctype", l10n_locale_category_t, LC_CTYPE'img );
  declareStandardConstant( l10n_lc_time_t, "l10n.lc_time", l10n_locale_category_t, LC_TIME'img );

  declareNamespaceClosed( "l10n" );

end StartupL10N;

procedure ShutdownL10N is
begin
  null;
end ShutdownL10N;

end parser_l10n;
