------------------------------------------------------------------------------
-- Localization Package Parser                                              --
--                                                                          --
-- Part of SparForte                                                        --
------------------------------------------------------------------------------
--                                                                          --
--            Copyright (C) 2001-2021 Free Software Foundation              --
--                                                                          --
-- This is free software;  you can  redistribute it  and/or modify it under --
-- terms of the  GNU General Public License as published  by the Free Soft- --
-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
-- sion.  This is distributed in the hope that it will be useful, but WITH- --
-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
-- for  more details.  You should have  received  a copy of the GNU General --
-- Public License  distributed with this;  see file COPYING.  If not, write --
-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
-- MA 02111-1307, USA.                                                      --
--                                                                          --
-- This is maintained at http://www.pegasoft.ca                             --
--                                                                          --
------------------------------------------------------------------------------

with ada.strings.unbounded,
#if L10N
     spar_os.l10n,
#end if;
     world,
     scanner,
     parser_params;
use  ada.strings.unbounded,
#if L10N
     spar_os.l10n,
#end if;
     world,
     scanner,
     parser_params;

package body parser_l10n is

------------------------------------------------------------------------------
-- Localization package identifiers
------------------------------------------------------------------------------

l10n_codeset_t : identifier;
l10n_d_t_fmt_t : identifier;
l10n_d_fmt_t   : identifier;
l10n_t_fmt_t   : identifier;
l10n_day_t     : identifier;
l10n_abday_t   : identifier;
l10n_mon_t     : identifier;
l10n_abmon_t   : identifier;
l10n_radixchar_t : identifier;
l10n_thousep_t : identifier;
l10n_yesexpr_t : identifier;
l10n_noexpr_t  : identifier;
l10n_crncystr_t: identifier;


---------------------------------------------------------
--
-- PARSE THE L10N PACKAGE
--
---------------------------------------------------------

#if not L10N
procedure not_configured( result : out unbounded_string; kind : out identifier ) is
begin
  result := null_unbounded_string;
  kind := universal_t;
  err( "l10n support not configured" );
end not_configured;
#end if;

-----------------------------------------------------------------------------
--  PARSE L10N CODESET
--
-- Syntax: l10n.codeset;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NCodeSet( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_codeset_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := codeset;
end ParseL10NCodeSet;
#else
procedure ParseL10NCodeSet( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;

-----------------------------------------------------------------------------
--  PARSE L10N D T FMT (Date and Time Format)
--
-- Syntax: l10n.d_fmt;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NDTFmt( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_d_t_fmt_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  if isExecutingCommand then
     result := d_t_fmt;
  end if;
end ParseL10NDTFmt;
#else
procedure ParseL10NDTFmt( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N D FMT (Date Format)
--
-- Syntax: l10n.d_fmt;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NDFmt( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_d_fmt_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  if isExecutingCommand then
     result := d_fmt;
  end if;
end ParseL10NDFmt;
#else
procedure ParseL10NDFmt( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;



-----------------------------------------------------------------------------
--  PARSE L10N T FMT (Time Format)
--
-- Syntax: l10n.t_fmt;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NTFmt( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_t_fmt_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  if isExecutingCommand then
     result := t_fmt;
  end if;
end ParseL10NTFmt;
#else
procedure ParseL10NTFmt( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N DAY (Day of Week)
--
-- Syntax: l10n.day( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NDay( result : out unbounded_string; kind : out identifier ) is
  dayExpr : unbounded_string;
  dayKind : identifier;
  day     : positive;
begin
  kind := uni_string_t;
  expect( l10n_day_t );
  ParseSingleNumericParameter( dayExpr, dayKind, positive_t );
  if isExecutingCommand then
     begin
        day := positive( to_numeric( dayExpr ) );
        case day is
        when 1 => result := day_1;
        when 2 => result := day_2;
        when 3 => result := day_3;
        when 4 => result := day_4;
        when 5 => result := day_5;
        when 6 => result := day_6;
        when 7 => result := day_7;
        when others =>
          err( "day is 1..7" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NDay;
#else
procedure ParseL10NDay( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N AB DAY (Abbreviated Day of Week)
--
-- Syntax: l10n.abday( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NAbDay( result : out unbounded_string; kind : out identifier ) is
  dayExpr : unbounded_string;
  dayKind : identifier;
  day     : positive;
begin
  kind := uni_string_t;
  expect( l10n_abday_t );
  ParseSingleNumericParameter( dayExpr, dayKind, positive_t );
  if isExecutingCommand then
     begin
        day := positive( to_numeric( dayExpr ) );
        case day is
        when 1 => result := abday_1;
        when 2 => result := abday_2;
        when 3 => result := abday_3;
        when 4 => result := abday_4;
        when 5 => result := abday_5;
        when 6 => result := abday_6;
        when 7 => result := abday_7;
        when others =>
          err( "day is 1..7" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NAbDay;
#else
procedure ParseL10NAbDay( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N MON (Month)
--
-- Syntax: l10n.mon( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NMon( result : out unbounded_string; kind : out identifier ) is
  monExpr : unbounded_string;
  monKind : identifier;
  mon     : positive;
begin
  kind := uni_string_t;
  expect( l10n_mon_t );
  ParseSingleNumericParameter( monExpr, monKind, positive_t );
  if isExecutingCommand then
     begin
        mon := positive( to_numeric( monExpr ) );
        case mon is
        when 1 => result := mon_1;
        when 2 => result := mon_2;
        when 3 => result := mon_3;
        when 4 => result := mon_4;
        when 5 => result := mon_5;
        when 6 => result := mon_6;
        when 7 => result := mon_7;
        when 8 => result := mon_8;
        when 9 => result := mon_9;
        when 10 => result := mon_10;
        when 11 => result := mon_11;
        when 12 => result := mon_12;
        when others =>
          err( "month is 1..12" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NMon;
#else
procedure ParseL10NMon( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N AB MON (Abbreviated Month)
--
-- Syntax: l10n.abmon( d );
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NAbMon( result : out unbounded_string; kind : out identifier ) is
  monExpr : unbounded_string;
  monKind : identifier;
  mon     : positive;
begin
  kind := uni_string_t;
  expect( l10n_abmon_t );
  ParseSingleNumericParameter( monExpr, monKind, positive_t );
  if isExecutingCommand then
     begin
        mon := positive( to_numeric( monExpr ) );
        case mon is
        when 1 => result := abmon_1;
        when 2 => result := abmon_2;
        when 3 => result := abmon_3;
        when 4 => result := abmon_4;
        when 5 => result := abmon_5;
        when 6 => result := abmon_6;
        when 7 => result := abmon_7;
        when 8 => result := abmon_8;
        when 9 => result := abmon_9;
        when 10 => result := abmon_10;
        when 11 => result := abmon_11;
        when 12 => result := abmon_12;
        when others =>
          err( "month is 1..12" );
        end case;
     exception when others =>
        err_exception_raised;
     end;
  end if;
end ParseL10NAbMon;
#else
procedure ParseL10NAbMon( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N RADIX CHAR
--
-- Syntax: l10n.radixchar;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NRadixChar( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_radixchar_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := radixchar;
end ParseL10NRadixChar;
#else
procedure ParseL10NRadixChar( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N THOU SEP (Thousands Separator)
--
-- Syntax: l10n.thousep;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NThouSep( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_thousep_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := thousep;
end ParseL10NThouSep;
#else
procedure ParseL10NThouSep( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N YES EXPR (Yes Expression)
--
-- Syntax: l10n.yesexpr;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NYesExpr( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_yesexpr_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := yesexpr;
end ParseL10NYesExpr;
#else
procedure ParseL10NYesExpr( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N NO EXPR (No Expression)
--
-- Syntax: l10n.noexpr;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NNoExpr( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_noexpr_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := noexpr;
end ParseL10NNoExpr;
#else
procedure ParseL10NNoExpr( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-----------------------------------------------------------------------------
--  PARSE L10N CRNCY STR (Currency String)
--
-- Syntax: l10n.crncystr;
-- Source: N/A
-----------------------------------------------------------------------------

#if L10N
procedure ParseL10NCrncyStr( result : out unbounded_string; kind : out identifier ) is
begin
  kind := uni_string_t;
  expect( l10n_crncystr_t );
  if token = symbol_t and identifiers( token ).value.all = "(" then
     expect( symbol_t, "(" );
     expect( symbol_t, ")" );
  end if;
  result := crncystr;
end ParseL10NCrncyStr;
#else
procedure ParseL10NCrncyStr( result : out unbounded_string; kind : out identifier ) renames not_configured;
#end if;


-------------------------------------------------------------------------------
--
-- Housekeeping
--
-------------------------------------------------------------------------------


procedure StartupL10N is
begin
  declareNamespace( "l10n" );

  declareFunction( l10n_codeset_t, "l10n.codeset", ParseL10NCodeSet'access );
  declareFunction( l10n_d_t_fmt_t, "l10n.d_t_fmt", ParseL10NDTFmt'access );
  declareFunction( l10n_d_fmt_t, "l10n.d_fmt", ParseL10NDFmt'access );
  declareFunction( l10n_t_fmt_t, "l10n.t_fmt", ParseL10NTFmt'access );
  declareFunction( l10n_day_t, "l10n.day", ParseL10NDay'access );
  declareFunction( l10n_abday_t, "l10n.abday", ParseL10NAbDay'access );
  declareFunction( l10n_mon_t, "l10n.mon", ParseL10NMon'access );
  declareFunction( l10n_abmon_t, "l10n.abmon", ParseL10NAbMon'access );
  declareFunction( l10n_radixchar_t, "l10n.radixchar", ParseL10NRadixChar'access );
  declareFunction( l10n_thousep_t, "l10n.thousep", ParseL10NThouSep'access );
  declareFunction( l10n_yesexpr_t, "l10n.yesexpr", ParseL10NYesExpr'access );
  declareFunction( l10n_noexpr_t, "l10n.noexpr", ParseL10NNoExpr'access );
  declareFunction( l10n_crncystr_t, "l10n.crncystr", ParseL10NCrncyStr'access );

  declareNamespaceClosed( "l10n" );

end StartupL10N;

procedure ShutdownL10N is
begin
  null;
end ShutdownL10N;

end parser_l10n;
