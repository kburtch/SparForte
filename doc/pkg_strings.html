<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/transitional.dtd">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <META NAME="description" CONTENT="SparForte language documentation">
	<title>SparForte - Packages - Strings</title>
	<link rel="StyleSheet" type="text/css" media="screen" href="art/sparforte.css">
	<link rel="index" href="packages.html" />
	<link rel="prev" href="pkg_stats.html" />
	<link rel="next" href="pkg_system.html" />
</head>
<body bgcolor="#FFFFFF"><a name="top"></a>
	<table width="100%" cellspacing="0" cellpadding="0" summary="page layout">
		<tr><td align="left"><img src="art/sparforte.png" alt="[SparForte]"></td><td align="right"><img src="art/header_cloud.png" alt="[Banner]"></td></tr>
		<tr><td background="art/header_border.png" height="10" colspan="2"></td></tr>
		<tr><td colspan="2"><table width="100%" border="0" cellspacing="0" cellpadding="0" summary="top menu">
			<tr>
				<td width="10"><img src="art/menu_left.png" alt="[Top Main Menu]"></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="intro_preface.html">Intro</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="tutorial_1.html">Tutorials</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="ref_adascript.html">Reference</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="packages.html"><b>Packages</b></a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="../examples/index.html">Examples</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="cont_vision.html">Contributors</a></td>
				<td background="art/menu_border.png" align="center">&nbsp;</td>
				<td background="art/menu_border.png" align="right"><a href="pkg_stats.html"><img src="art/left_arrow.png" width="27" height="24" alt="[Back Page]" border="0"></a><span class="menutext">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="pkg_system.html"><img src="art/right_arrow.png" width="27" height="24" alt="[Next Page]" border="0"></a></td>
				<td background="art/menu_border.png">&nbsp;</td>
</tr></table></td></tr>
	</table>
	<noscript>
	<a href="#submenu">[Jump to Submenu]</a>
	<hr />
	</noscript>
	<table width="100%" border="0" cellspacing="0" cellpadding="0" summary="content and right submenu">
		<tr>
			<td align="left" valign="top">
	<!-- Content Area -->
<h2><a NAME="4.8"></a>Strings Package</h2>
<p>The SparForte built-in strings package provides subprograms to manipulate string
and character values. (The character positions are numbered from 1.)</p>

<p><u>GCC Ada equivalent</u>: Ada.Strings.Unbounded, GNAT.Regexp, GNAT.Regpat

        <center>
        <div class="code">
<pre>
  <a href="#strings.count">n := count( s, p )</a>             <a href="#strings.csv_field">r := csv_field( s, c [, d] )</a>  <a href="#strings.csv_replace">r := csv_replace( s, f, t, [, d] )</a>
  <a href="#strings.delete">r := delete( s, l, h )</a>         <a href="#strings.element">c := element( s, p )</a>          <a href="#strings.field">r := field( s, c [, d] )</a>
  <a href="#strings.glob">b := glob( e, s )</a>              <a href="#strings.head">r := head( s, c [, p] )</a>       <a href="#strings.image">r := strings.image( n )</a>
  <a href="#strings.index">n := index( s, p [, d] )</a>       <a href="#strings.index_non_blank">n := index_non_blank( s [,d] )</a> <a href="#strings.insert">r := insert( s, b, n )</a>
  <a href="#strings.is_alphanumeric">r := is_alphanumeric( s )</a>      <a href="#strings.is_basic">r := is_basic( s )</a>            <a href="#strings.is_control">r := is_control( s )</a>
  <a href="#strings.is_digit">r := is_digit( s )</a>             <a href="#strings.is_fixed">r := is_fixed( s )</a>            <a href="#strings.is_graphic">r := is_graphic( s )</a>          
  <a href="#strings.is_hexadecimal_digit">r := is_hexadecimal_digit( s )</a> <a href="#strings.is_letter">r := is_letter( s )</a>           <a href="#strings.is_lower">r := is_lower( s )</a>
  <a href="#strings.is_slashed_date">r := is_slashed_date( s )</a>      <a href="#strings.is_special">r := is_special( s )</a>          <a href="#strings.is_typo_of">b := is_typo_of( s1, s2 )</a>
  <a href="#strings.is_upper">r := is_upper( s )</a>             <a href="#strings.length">n := length( s )</a>              <a href="#strings.lookup">r := lookup( s, k [, d] )</a>
  <a href="#strings.match">b := match( e, s )</a>             <a href="#strings.mktemp">r := mktemp( p )</a>              <a href="#strings.overwrite">r := overwrite( s, p, n )</a>
  <a href="#strings.replace">replace( s, f, t [, d] )</a>       <a href="#strings.replace_slice">replace_slice( s, l, h, b )</a>   <a href="#strings.set_unbounded_string">set_unbounded_string( u, s )</a>
  <a href="#strings.slice">r := slice( s, l, h )</a>          <a href="#strings.split">split( s, l, r , p )</a>          <a href="#strings.tail">r := tail( s, c [, p] )</a>
  <a href="#strings.to_basic">r := to_basic( s )</a>             <a href="#strings.to_escaped">r := to_escaped( s )</a>          <a href="#strings.to_json">r := to_json( s )</a>
  <a href="#strings.to_lower">r := to_lower( s )</a>             <a href="#strings.to_proper">r := to_proper( s )</a>           <a href="#strings.to_string">r := to_string( s )</a>
  <a href="#strings.to_upper">r := to_upper( s )</a>             <a href="#strings.to_unbounded_string">u := to_unbounded_string( s )</a> <a href="#strings.trim">r := trim( s [, e] )</a>
  <a href="#strings.unbounded_slice">r := unbounded_slice( s, l, h )</a> <a href="#strings.val">c := val( n )</a> 
</pre>
        &nbsp;<br>
        <div class="code_caption">
        <b>Help Command</b>: Contents of the strings package</span>
        </div>
        </div>
        </center>

<p>Ada implements three different kinds of strings: standard "fixed" strings,
bounded strings and unbounded strings. They are implemented in different
packages and are incompatible with one another. The standard strings are
implemented as arrays and cannot be used in SparForte since AdaScript had no
array capabilities. SparForte implements strings as Ada unbounded strings.
<p>For ease of use, string literals (like "hello world") are universal_string
types in AdaScript, but are fixed string types in Ada. String literals
should properly be converted to an unbounded string using the to_unbounded_string
(to_unbounded_string( "hello world" ) even though AdaScript doesn't enforce
this.
<p>Likewise unbounded strings should be declared as "unbounded_string"
type variables. For ease of use, SparForte uses "string" instead.
<p>When porting a script to Ada, unbounded_string types, to_unbounded_string
and to_string functions should be used.
<p>There are 5 enumerated types used by the string functions:
<ul>
<li><b>strings.alignment</b> - alignment.left, alignment.right or alignment.center</li>
<li><b>strings.truncation</b> - truncation.left, truncation.right or truncation.error</li>
<li><b>strings.membership</b> - membership.inside or membership.outside</li>

<li><b>strings.direction</b> - direction.forward or direction.backward</li>
<li><b>strings.trim_end</b> - trim_end.left, trim_end.right or trim_end.both</li>
</ul>

<a name="strings.count"></a><h3>n := strings.count( s, p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the occurrences in string s of substring p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.count( "baby", "b" ); -- returns 2</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to check</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the substring to search for</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of occurrences (0 if none)</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Count<br>PHP: substr_count</p></td>
</tr>
</table>

<a name="strings.csv_field"></a><h3>r := strings.csv_field( s, c [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the natural cth substring of s delimited by character d (typically a comma).  Double quotes will escape the delimiter.  For use with Comma Separated Value files.  A bad position returns an empty string (like the Linux/UNIX cut command).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.csv_field( "a/b/c", 2, '/' ); -- returns "b"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the field position (1 for first field)</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>','</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the field</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.field">strings.field</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.lookup">strings.lookup</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_getcsv</p></td>
</tr>
</table>

<a name="strings.csv_replace"></a><h3>r := strings.csv_replace( s, f, t, [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>replace the natural fth substring of s delimited by character d (typically a comma) with string t.  Double quotes will escape the delimiter.  For use with Comma Separated Value files (or ASCII.TAB for tab separated value file).  A bad position returns an empty string (like the Linux/UNIX cut command).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.csv_replace( "a/b/c", 2, "x", '/' ); -- now "a/x/c"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>f</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the field position (1 for first field)</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the new field value</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>','</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the field</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.replace_slice">strings.replace_slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_putcsv</p></td>
</tr>
</table>

<a name="strings.delete"></a><h3>r := strings.delete( s, l, h )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return a string with character positions positive l to natural h deleted</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.delete( "bowl", 4, 4 ); -- returns "bow"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>low position to delete (1 is the start of the string).</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the high position to delete.</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the string with the positions removed</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad position raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.head">strings.head</a><br><a href="#strings.slice">strings.slice</a><br><a href="#strings.tail">strings.tail</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada.Strings.Unbounded.Delete</p></td>
</tr>
</table>

<a name="strings.element"></a><h3>c := strings.element( s, p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the character located at positive position p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">c := strings.element( "baby", 2 ); -- returns 'a'</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the string position (1 is the first character).</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>return value</span></td>
<td><span>character</span></td>
<td><span>required</span></td>
<td><span>the character</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad position raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.delete">strings.delete</a><br><a href="#strings.head">strings.head</a><br><a href="#strings.slice">strings.slice</a><br><a href="#strings.tail">strings.tail</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Element</p></td>
</tr>
</table>

<a name="strings.field"></a><h3>r := strings.field( s, c [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the natural cth substring of s delimited by character d.  A bad position returns an empty string (like the Linux/UNIX cut command).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.field( "a/b/c", 2, '/' ); -- returns "b"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the field position (1 for first field)</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>ASCII.CR</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the field</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.replace">strings.replace</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Perl: split<br>PHP: explode</p></td>
</tr>
</table>

<a name="strings.glob"></a><h3>b := strings.glob( e, s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return true if string globbing expression e. Globbing characters include:</p>
<ul>
<li>
<b>*</b> - zero or more characters</li>
<li>
<b>?</b> - a single character</li>
<li>
<b>[...]</b> - a set of characters</li>
<li>
<b>[^...]</b> - any not in set of characters</li>
<li>
<b>[c1...c2]</b> - a range of characters between c1 and c2</li>
</ul>
</td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.glob( "app*", "apple" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the globbing pattern to use</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the pattern matched</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.index">strings.index</a><br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: GNAT.RegPat.Match</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>This should rightly be strings.match but the name conflicts with the
other strings.match.  Glob also is a more descriptive name.</p></td>
</tr>
</table>

<a name="strings.head"></a><h3>r := strings.head( s, c [, p] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the first natural c characters of string s. If the number of
characters is greater than the strings, the remaining characters will be
padded using character p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.head( "minimum", 3 ); -- returns "min"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of characters (0 for none)</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>' '</span></td>
<td><span>character to pad with if string is short</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad count raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.delete">strings.delete</a><br><a href="#strings.element">strings.element</a><br><a href="#strings.slice">strings.slice</a><br><a href="#strings.tail">strings.tail</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Head</p></td>
</tr>
</table>

<a name="strings.image"></a><h3>r := strings.image( n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert numeric value n to a string representation of the same value (inverse of numerics.value)</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.image( 35 ); -- retuns "35"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the number to convert</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the value as a string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="pkg_numerics.html#numerics.value">numerics.value</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: 'image attribute<br>PHP: strval</p></td>
</tr>
</table>

<a name="strings.index"></a><h3>n := strings.index( s, p [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the first position of substring p in string s in direction d.  Returns zero if the substring doesn't exist.  The search is case-sensitive.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.index( "catapult", "tap" ); -- returns 3</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the substring to find</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>strings.direction</span></td>
<td><span>direction.forward</span></td>
<td><span>the direction of the search (forward from start or backward from end)</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the position of the match (0 if none)</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a>_non_blank<br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Index<br>Perl: index / rindex<br>PHP: strpos / strrpos</p></td>
</tr>
</table>

<a name="strings.index_non_blank"></a><h3>n := strings.index_non_blank( s [,d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the first non-space position in string s in direction d.  Returns zero if the string is all spaces.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.index_non_blank( " moon" ); -- retuns 2</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>strings.direction</span></td>
<td><span>direction.forward</span></td>
<td><span>the direction of the search</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the position of the first character that is not a space</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Index_Non_Blank</p></td>
</tr>
</table>

<a name="strings.insert"></a><h3>r := strings.insert( s, b, n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a string with substring n inserted into string s before position positive b</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.insert( "ale", 2, "pp" ); -- returns "apple"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to insert another string into</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the position to insert the substring</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the substring to insert</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.overwrite">strings.overwrite</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Insert</p></td>
</tr>
</table>

<a name="strings.is_alphanumeric"></a><h3>r := strings.is_alphanumeric( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains alphanumeric chararacters (that is, the same as is_letter and is_digit).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_alphanumeric( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is alphanumeric</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Alphanumeric<br>PHP: ctype_alnum</p></td>
</tr>
</table>

<a name="strings.is_basic"></a><h3>r := strings.is_basic( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains basic Latin-1 letters (A..Z, a..z, AE Diphtong, Icelandic Eth, Icelandic Thorn, German Sharp S).   Accented characters are not included.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.basic( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is basic</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Basic</p></td>
</tr>
</table>

<a name="strings.is_control"></a><h3>r := strings.is_control( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains control chararacters (ASCII/Latin-1 0..31 and 127..159).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.control( "hello" ); -- returns false</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is control characters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Control<br>PHP: ctype_cntrl</p></td>
</tr>
</table>

<a name="strings.is_digit"></a><h3>r := strings.is_digit( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string completely contains numeric digits (ASCII/Latin-1 48..57).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_digit( "1234567890" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is digits</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Digit<br>PHP: ctype_digit</p></td>
</tr>
</table>

<a name="strings.is_fixed"></a><h3>r := strings.is_fixed( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string appears to be a fixed point number (that is, a number with a decimal point).  No check is made to see if the number is representable by AdaScript.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_fixed( "340.12" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is a number with a decimal point</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.is_graphic"></a><h3>r := strings.is_graphic( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string completely contains printable characters (that is, not is_control).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_graphic( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is printable</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Graphic<br>PHP: ctype_graph</p></td>
</tr>
</table>

<a name="strings.is_hexadecimal_digit"></a><h3>r := strings.is_hexadecimal_digit( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string completely contains hexadecimal numeric characters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_hexadecimal_digit( "FE00" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is hexadecimal</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Hexadecimal_Digit<br>PHP: ctype_xdigit</p></td>
</tr>
</table>

<a name="strings.is_letter"></a><h3>r := strings.is_letter( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains Latin-1 letters (that is, is_basic plus accented characters).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_letter( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is letters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Letter<br>PHP: ctype_alpha</p></td>
</tr>
</table>

<a name="strings.is_lower"></a><h3>r := strings.is_lower( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains Latin-1 lower-case letters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_lower( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is lower-case letters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Lower<br>PHP: ctype_lower</p></td>
</tr>
</table>

<a name="strings.is_slashed_date"></a><h3>r := strings.is_slashed_date( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string appears to be an 8 or 10 character slashed date.  No check is made to see if the date is a real date.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_slashed_date( "11/22/2003" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is a date</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.is_special"></a><h3>r := strings.is_special( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains special printable characters such as punctuation marks (that is, is_graphic and not is_alphanumeric).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_special( "!" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is special</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Special<br>PHP: ctype_punct</p></td>
</tr>
</table>

<a name="strings.is_typo_of"></a><h3>b := strings.is_typo_of( s1, s2 )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string s1 is similar to s2.  false if the strings are the same, if the strings are too short to test or if the strings are very different.  The function is case-sensitive.  This is the same algorithm used by SparForte to check for identifiers with spelling mistakes.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.is_typo_of( "apple", "app1e" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s1</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the first string to compare</span></td>
</tr>
<tr>
<td><span>s2</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the second string to compare</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the strings are a possible typo</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: levenshtein / similar_text</p></td>
</tr>
</table>

<a name="strings.is_upper"></a><h3>r := strings.is_upper( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains Latin-1 upper-case letters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_upper( "HELLO" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>true if the string is upper-case letters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.is_lower">strings.is_lower</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Upper<br>PHP: ctype_upper</p></td>
</tr>
</table>

<a name="strings.length"></a><h3>n := strings.length( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the number of characters in the string.  Returns zero if the string is empty.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.length( "bounce" ); -- retuns 6</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to count</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of characters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Length<br>PHP: strlen</p></td>
</tr>
</table>

<a name="strings.lookup"></a><h3>r := strings.lookup( s, k [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>String s contains pairs of key-value substrings delimited by character d.  Return the right-hand (value) substring of the pair beginning with left-hand (key) field k.  An empty string is returned if the key is not found.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.lookup( "a/b/c/d", "c", '/' ); -- returns "d" from pair "c/d"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>k</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the key to find</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>ASCII.CR</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the value of the key</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.index">strings.index</a>_non_blank<br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.match"></a><h3>b := strings.match( e, s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return true if the string matches regular expression with PERL extensions.</p>
<p>Match characters include:
<ul>
<li><b>^</b> - at beginning</li> 
<li><b>.</b> - any character</li>
<li><b>$</b> - at end</li>
<li><b>?</b> - zero or one character</li>
<li><b>[s]</b> - any in set s</li>
<li><b>+</b> - one or more characters</li>
<li><b>[^s]</b> - any not in set s</li>
<li><b>*</b> - zero or more characters</li>
<li><b>\</b> - escape character</li>
<li><b>(e)</b> - nested expression</li>
<li><b>|</b> - alternative</li>
</ul></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.match( "^app", "apple" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the regular expression</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the pattern matched</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.index">strings.index</a>_non_blank<br><a href="#strings.lookup">strings.lookup</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: GNAT.RegExp.Match<br>Perl: m//<br>PHP: preg_match</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Note</p></td>
<td><p>There's a known bug in GNAT 3.12 and 3.13 which causes strings.match to fail.</p></td>
</tr>
</table>

<a name="strings.mktemp"></a><h3>r := strings.mktemp( p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Make a temporary file name using template p (like UNIX/Linux mktemp command)</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.mktemp( "tempXXXXXX" );</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the path template ending with 6 dummy characters</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the path with the dummy characters replaced with random characters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: tempnam</p></td>
</tr>
</table>

<a name="strings.overwrite"></a><h3>r := strings.overwrite( s, p, n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a string with substring n overwriting positions starting at positive p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.overwrite( "goose", 2, "ee" ); -- returns "geese"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to overwrite</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the position to start replacing characters</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the substring to replace characters with</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.insert">strings.insert</a><br><a href="#strings.replace_slice">strings.replace_slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Overwrite<br>PHP: substr_replace</p></td>
</tr>
</table>

<a name="strings.replace"></a><h3>strings.replace( s, f, t [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>s contains substring fields delimited by character d.  Replace the fth substring field with new substring t.  No change is made for a position that doesn't exist.  </p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.replace( s, 2, "*", '/' ); -- if s is "a/b/c", it is now "a/*/c"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>f</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the index of the field to change</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new substring</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>ASCII.CR</span></td>
<td><span>the character delimiter</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad low position will raise an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.field">strings.field</a><br><a href="#strings.lookup">strings.lookup</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.replace_slice"></a><h3>replace_slice( s, l, h, b )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Replace the characters in s between positions low l and hight h with substring b</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.replace( s, 2, 3, , 'foo' ); -- if s is "1234", it is now "1foo34"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the position of the first character</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the position of the last character</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad low position will raise an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.insert">strings.insert</a><br><a href="#strings.overwrite">strings.overwrite</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.set_unbounded_string"></a><h3>strings.set_unbounded_string( u, s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Set unbounded string u with the value of string s.  Provided for Ada 2005 compatibility.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.set_unbounded_string( u, "foo" ); -- u is now "foo"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>u</span></td>
<td><span>in out</span></td>
<td><span>unbounded_string</span></td>
<td><span>required</span></td>
<td><span>the string to set</span></td>
</tr>
<tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the string to provide the value</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Set_Unbounded_String</p></td>
</tr>
</table>

<a name="strings.slice"></a><h3>r := strings.slice( s, l, h )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a substring between the positions positive l and natural h.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.slice( "realize", 2, 4 ); -- returns "eal"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to overwrite</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>low position to start replacing characters</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>high position to finish replacing characters</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad low position will raise an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Slice<br>PHP: substr</p></td>
</tr>
</table>

<a name="strings.split"></a><h3>strings.split( s, l, r , p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Split string s into a left substring l and a right substring r at or to the left of character position p.  split will attempt to split on the nearest space.  A bad position will be constrained to legal values.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.split( "hello there", l, r, 9 ); -- l is "hello " and r is "there"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to split</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>out</span></td>
<td><span>unbounded_string</span></td>
<td><span>required</span></td>
<td><span>the left substring of s</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the right substring of s</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the maximum width of the left substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: wordwrap</p></td>
</tr>
</table>

<a name="strings.tail"></a><h3>r := strings.tail( s, c [, p] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the last natural c characters of string s</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.tail( "maximum", 3 ); -- returns "mum"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of characters (0 for none)</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>' '</span></td>
<td><span>character to pad with if string is short</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad count raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.delete">strings.delete</a><br><a href="#strings.element">strings.element</a><br><a href="#strings.head">strings.head</a><br><a href="#strings.slice">strings.slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Tail</p></td>
</tr>
</table>

<a name="strings.to_basic"></a><h3>r := strings.to_basic( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert the string to basic letters (as defined for strings.is_basic).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_basic( "hello" ); -- retuns "hello"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the basic string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.is_basic">strings.is_basic</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.To_Basic</p></td>
</tr>
</table>

<a name="strings.to_escaped"></a><h3>r := strings.to_escaped( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert the string to printable character by replacing control characters with "[# n]" where n is the ASCII/Latin-1 position.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_escaped( "hello" &amp; ASCII.CR ); -- retuns "hello[# 13]"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the escaped string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.to_lower"></a><h3>r := strings.to_lower( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the string in lower-case</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_lower( "bOunce" ); -- retuns "bounce"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the lower-case string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: strtolower</p></td>
</tr>
</table>

<a name="strings.to_proper"></a><h3>r := strings.to_proper( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the string in proper (or mixed or title) case</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.to_proper( "proper" ); -- retuns "Proper"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the proper-case string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: ucwords</p></td>
</tr>
</table>

<a name="strings.to_json"></a><h3>r := strings.to_json( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the JSON encoding of the string.  Encoding arbitrary control characters with \u is not yet supported, though carriage returns, line feeds, etc. are supported.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_json( "foobar" &amp; ASCII.LF &amp; "test" ); -- returns "foobar\ntest"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the string expression to encode</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the JSON string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.to_string">strings.to_string</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: json_encode</p></td>
</tr>
</table>

<a name="strings.to_string"></a><h3>r := strings.to_string( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert unbounded string s to string s. If u is a json_string, convert JSON encoding of a string into the original string. Encoding arbitrary control characters with \u is not yet supported, though carriage returns, line feeds, etc. are supported. universal_string types (including string literals) are not accepted.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.to_string( some_unbounded_string );<br>r := strings.to_string( json_string( ASCII.Quotation &amp; "foobar\ntest" &amp; ASCII.Quotation ) ); -- returns a string with foobar, a line feed, and test</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the string expression to encode</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the JSON string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>Bad JSON data can raise exceptions</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="pkg_arrays.html#arrays.to_array">arrays.to_array</a><br><a href="pkg_records.html#records.to_record">records.to_record</a><br><a href="#strings.to_string">strings.to_string</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.To_String<br>PHP: json_decode</p></td>
</tr>
</table>

<a name="strings.to_unbounded_string"></a><h3>u := strings.to_unbounded_string( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert string s to unbounded string u.  For compatibility with Ada 95.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">unbounded_string := strings.to_unbounded_string( "test" );</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the fixed string to covert</span></td>
</tr>
<tr>
<td><span>u</span></td>
<td><span>return value</span></td>
<td><span>unbounded_string</span></td>
<td><span>required</span></td>
<td><span>the unbounded string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.to_upper"></a><h3>r := strings.to_upper( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the string in upper-case</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.to_upper( "BoUNCE" ); -- retuns "BOUNCE"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the upper-case string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.is_upper">strings.is_upper</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: strtoupper</p></td>
</tr>
</table>

<a name="strings.trim"></a><h3>r := strings.trim( s [, e] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Remove leading and/or trailing spaces (depending on e) from string s</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.trim( "&nbsp; many&nbsp; " ); -- returns "many"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to trim</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>strings.trim_end</span></td>
<td><span>trim_end.both</span></td>
<td><span>the end(s) of string to trim</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Trim<br>PHP: trim</p></td>
</tr>
</table>

<a name="strings.unbounded_slice"></a><h3>r := strings.unbounded_slice( s, l, h )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a substring between the positions positive l and natural h.  For compatibility with Ada&mdash;normally use strings.slice.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.unbounded_slice( "realize", 2, 4 ); -- returns "eal"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to overwrite</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>low position to start replacing characters</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>high position to finish replacing characters</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>unbounded_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.slice">strings.slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Unbounded_Slice</p></td>
</tr>
</table>

<a name="strings.val"></a><h3>c := strings.val( n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the ASCII character with value n (inverse of numerics.pos)</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.val( 65 ); -- returns 'A'</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the ASCII value</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>return value</span></td>
<td><span>character</span></td>
<td><span>required</span></td>
<td><span>the character</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: 'val attribute<br>PHP: ord</p></td>
</tr>
</table>

&nbsp;<br>

			</td>
			<td bgcolor="#d3c7f8" width="150" align="right" valign="top"><noscript><hr /></noscript><img src="art/right_menu_top.png" width="150" height="24" alt="[Right Submenu]"><br><a name="submenu"></a>
                                <p class="rmt"><a class="rightmenutext" href="packages.html">&nbsp;Summary</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_arrays.html">&nbsp;arrays</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_calendar.html">&nbsp;calendar</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_cgi.html">&nbsp;cgi</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_chains.html">&nbsp;chains</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_cmdline.html">&nbsp;command_line</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_db.html">&nbsp;db/ postgresql</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_dirops.html">&nbsp;directory_operations</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_enums.html">&nbsp;enums</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_exceptions.html">&nbsp;exceptions</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_files.html">&nbsp;files</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_gnat_cgi.html">&nbsp;gnat.cgi</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_gnat_crc32.html">&nbsp;gnat.crc32</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_lock_files.html">&nbsp;lock_files</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_memcache.html">&nbsp;memcache</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_memcache_highread.html">&nbsp;memcache.highread</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_mysql.html">&nbsp;mysql</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_mysqlm.html">&nbsp;mysqlm</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_numerics.html">&nbsp;numerics</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_os.html">&nbsp;os</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_pen.html">&nbsp;pen</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_pen.html">&nbsp;pen (OpenGL)</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_records.html">&nbsp;records</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_sound.html">&nbsp;sound</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_sinfo.html">&nbsp;source_info</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_stats.html">&nbsp;stats</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_strings.html">&nbsp;<b>strings</b></a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_system.html">&nbsp;System</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_text_io.html">&nbsp;text_io</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_units.html">&nbsp;units</a></p>
</a></p>

			</td>
		</tr>
		<tr>
			<td bgcolor="#d3c7f8" align="left" valign="middle"><a href="#top"><img src="art/up_arrow.png" border="0" width="24" height="27" alt="[Back to Top]"><span>&nbsp;Back To Top</span></a></td>
			<td bgcolor="#d3c7f8" align="center" valign="middle"><img src="art/forte_small.png" width="26" height="32" border="0" alt="[Small Forte Symbol]"></td>
	       	</tr>

	</table>

</body>
</html>

