<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/transitional.dtd">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="description" CONTENT="SparForte language documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SparForte - Packages - Strings</title>
	<link rel="StyleSheet" type="text/css" media="screen" href="art/sparforte.css">
	<link rel="index" href="packages.html" />
	<link rel="prev" href="pkg_stats.html" />
	<link rel="next" href="pkg_system.html" />
</head>
<body bgcolor="#FFFFFF"><a name="top"></a>
	<table width="100%" cellspacing="0" cellpadding="0" summary="page layout">
		<tr><td align="left"><img src="art/sparforte.png" alt="[SparForte]"></td><td align="right"><img src="art/header_cloud.png" alt="[Banner]"></td></tr>
		<tr><td background="art/header_border.png" height="10" colspan="2"></td></tr>
		<tr><td colspan="2"><table width="100%" border="0" cellspacing="0" cellpadding="0" summary="top menu">
			<tr>
				<td width="10"><img src="art/menu_left.png" alt="[Top Main Menu]"></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="intro_preface.html">Intro</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="tutorial_1.html">Tutorials</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="ref_adascript.html">Reference</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="packages.html"><b>Packages</b></a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="../examples/index.html">Examples</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="cont_vision.html">Contributors</a></td>
				<td background="art/menu_border.png" align="center">&nbsp;</td>
				<td background="art/menu_border.png" align="right"><a href="pkg_stats.html"><img src="art/left_arrow.png" width="27" height="24" alt="[Back Page]" border="0"></a><span class="menutext">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="pkg_system.html"><img src="art/right_arrow.png" width="27" height="24" alt="[Next Page]" border="0"></a></td>
				<td background="art/menu_border.png">&nbsp;</td>
</tr></table></td></tr>
	</table>
	<noscript>
	<a href="#submenu">[Jump to Submenu]</a>
	<hr />
	</noscript>
	<table width="100%" border="0" cellspacing="0" cellpadding="0" summary="content and right submenu">
		<tr>
			<td align="left" valign="top">
	<!-- Content Area -->
<h2><a NAME="4.8"></a>Strings Package</h2>
<p>The SparForte built-in strings package provides subprograms to manipulate string
and character values. (The character positions are numbered from 1.)</p>

<p><u>GCC Ada equivalent</u>: Ada.Strings.Unbounded, GNAT.Regexp, GNAT.Regpat

        <center>
        <div class="code">
<pre>
  <a href="#strings.compare">i := compare( s, t [, c [, l] ] )</a>          <a href="#strings.count">n := count( s, p )</a>
  <a href="#strings.csv_field">r := csv_field( s, c [, d [, q]] )</a>         <a href="#strings.csv_replace">r := csv_replace( s, f, t, [, d [, q]] )</a>
  <a href="#strings.delete">r := delete( s, l, h )</a>                     <a href="#strings.element">c := element( s, p )</a>
  <a href="#strings.ends_with">b := ends_with( s, t [,c] )</a>                <a href="#strings.field">r := field( s, c [, d] )</a>
  <a href="#strings.glob">b := glob( e, s )</a>                          <a href="#strings.head">r := head( s, c [, p] )</a>
  <a href="#strings.image">r := image( n )</a>                            <a href="#strings.index">n := index( s, p [, d] )</a>
  <a href="#strings.index_non_blank">n := index_non_blank( s [,d] )</a>             <a href="#strings.index_set">n := index_set( s, t [, f [, m [, d] ] ] )</a>
  <a href="#strings.insert">r := insert( s, b, n )</a>                     <a href="#strings.is_alphanumeric">r := is_alphanumeric( s )</a>
  <a href="#strings.is_basic">r := is_basic( s )</a>                         <a href="#strings.is_control">r := is_control( s )</a>
  <a href="#strings.is_digit">r := is_digit( s )</a>                         <a href="#strings.is_fixed">r := is_fixed( s )</a>
  <a href="#strings.is_graphic">r := is_graphic( s )</a>                       <a href="#strings.is_hexadecimal_digit">r := is_hexadecimal_digit(s)</a>
  <a href="#strings.is_letter">r := is_letter( s )</a>                        <a href="#strings.is_lower">r := is_lower( s )</a>
  <a href="#strings.is_slashed_date">r := is_slashed_date( s )</a>                  <a href="#strings.is_special">r := is_special( s )</a>
  <a href="#strings.is_typo_of">b := is_typo_of( s1, s2 )</a>                  <a href="#strings.is_upper">r := is_upper( s )</a>
  <a href="#strings.length">n := length( s )</a>                           <a href="#strings.levenshtein">n := levenshtein( s1, s2 )</a>
  <a href="#strings.lookup">r := lookup( s, k [, d] )</a>                  <a href="#strings.match">b := match( e, s )</a>
  <a href="#strings.mktemp">r := mktemp( p )</a>                           <a href="#strings.overwrite">r := overwrite( s, p, n )</a>
  <a href="#strings.replace">replace( s, f, t [, d] )</a>                   <a href="#strings.replace_all">r := replace_all( s, n, t [, c] )</a>
  <a href="#strings.replace_slice">r := replace_slice( s, l, h, b )</a>           <a href="#strings.set_unbounded_string">set_unbounded_string( u, s )</a>
  <a href="#strings.slice">r := slice( s, l, h )</a>                      <a href="#strings.soundex">r := soundex( s )</a>
  <a href="#strings.split">split( s, l, r , p )</a>                       <a href="#strings.starts_with">b := starts_with( s, t [, c] )</a>
  <a href="#strings.tail">r := tail( s, c [, p] )</a>                    <a href="#strings.to_base64">r := to_base64( s )</a>
  <a href="#strings.to_basic">r := to_basic( s )</a>                         <a href="#strings.to_escaped">r := to_escaped( s )</a>
  <a href="#strings.to_hexadecimal_digits">s := to_hexadecimal_digits( n )</a>            <a href="#strings.to_json">r := to_json( s )</a>
  <a href="#strings.to_lower">r := to_lower( s )</a>                         <a href="#strings.to_proper">r := to_proper( s )</a>
  <a href="#strings.to_string">r := to_string( s )</a>                        <a href="#strings.to_unbounded_string">u := to_unbounded_string( s )</a>
  <a href="#strings.to_upper">r := to_upper( s )</a>                         <a href="#strings.trim">r := trim( s [, e] )</a>
  <a href="#strings.unbounded_slice">r := unbounded_slice(s, l, h)</a>              <a href="#strings.val">c := val( n )</a>
  <a href="#strings.word_count">n := word_count( s )</a>
</pre>
        &nbsp;<br>
        <div class="code_caption">
        <b>Help Command</b>: Contents of the strings package</span>
        </div>
        </div>
        </center>

<p>Ada implements three different kinds of strings: standard "fixed" strings,
bounded strings and unbounded strings. They are implemented in different
packages and are incompatible with one another. The standard strings are
implemented as arrays and cannot be used in SparForte since AdaScript had no
array capabilities. SparForte implements strings as Ada unbounded strings.
<p>For ease of use, string literals (like "hello world") are universal_string
types in AdaScript, but are fixed string types in Ada. String literals
should properly be converted to an unbounded string using the to_unbounded_string
(to_unbounded_string( "hello world" ) even though AdaScript doesn't enforce
this.
<p>Likewise unbounded strings should be declared as "unbounded_string"
type variables. For ease of use, SparForte uses "string" instead.
<p>When porting a script to Ada, unbounded_string types, to_unbounded_string
and to_string functions should be used.
<p>There are 5 enumerated types used by the string functions:
<ul>
<li><b>strings.alignment</b> - alignment.left, alignment.right or alignment.center</li>
<li><b>strings.truncation</b> - truncation.left, truncation.right or truncation.error</li>
<li><b>strings.membership</b> - membership.inside or membership.outside</li>

<li><b>strings.direction</b> - direction.forward or direction.backward</li>
<li><b>strings.trim_end</b> - trim_end.left, trim_end.right or trim_end.both</li>
<li><b>strings.sensitivity</b> - sensitivity.insensitive, sensitivity.sensitive</li>
</ul>

<p>There is also a string type, <b>strings.base64_string</b>, for use with
Base 64 encoded strings.</p>

<p>There is a <b>strings.null_unbounded_string</b>, a constant empty string
for compatibility with Ada.</p>

<a name="strings.compare"></a><h3>i := strings.compare( s, t [, c [, l] ] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return -1 if string s is less than string t, 1
if t is greater than s or zero if they are equal.  If length l is given,
only test the first l characters.  The default sensitivity
is case-sensitive.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">i := strings.compare( "apples", "oranges" ); -- i is -1</span><br><span class="code">i := strings.compare( "apples", "apples" ); -- i is 0</span><br><span class="code">i := strings.compare( "oranges", "apples" ); -- i is 1<br> i := strings.compare( "apples", "applesauce", sensitivity.sensitive, 6 ); -- i is 0</td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the first string</span></td>
</tr><tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the second string</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>strings.sensitivity</span></td>
<td><span>sensitivity.sensitive</span></td>
<td><span>the case sensitivity</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>last positive</span></td>
<td><span>the number of characters to test</span></td>
</tr>
<tr>
<td><span>i</span></td>
<td><span>return value</span></td>
<td><span>integer</span></td>
<td><span>required</span></td>
<td><span>result of the comparison</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: strcmp, strncmp, strcasecmp, strncasecmp</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>

<a name="strings.count"></a><h3>n := strings.count( s, p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the occurrences in string s of substring p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.count( "baby", "b" ); -- returns 2</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to check</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring to search for</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of occurrences (0 if none)</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Count<br>PHP: substr_count<br>Python: count</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.csv_field"></a><h3>r := strings.csv_field( s, c [, d [, q]] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the natural cth substring of s delimited by character d (typically a comma).  Double quotes will escape the delimiter.  For use with Comma Separated Value files.  A bad position returns an empty string (like the Linux/UNIX cut command).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.csv_field( "a/b/c", 2, '/' ); -- returns "b"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the field position (1 for first field)</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>','</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>q</span></td>
<td><span>in</span></td>
<td><span>boolean</span></td>
<td><span>false</span></td>
<td><span>allow single quotes around the field</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the field</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.field">strings.field</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.lookup">strings.lookup</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_getcsv</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.csv_replace"></a><h3>strings.csv_replace( s, f, t, [, d [, q] ] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>replace the natural fth substring of s delimited by character d (typically a comma) with string t.  Double quotes will escape the delimiter.  For use with Comma Separated Value files (or ASCII.TAB for tab separated value file).  A bad position returns an empty string (like the Linux/UNIX cut command).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := "a/b/c"; strings.csv_replace( s, 2, "x", '/' ); -- now "a/x/c"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>f</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the field position (1 for first field)</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the new field value</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>','</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>q</span></td>
<td><span>in</span></td>
<td><span>boolean</span></td>
<td><span>false</span></td>
<td><span>allow single quotes around the field</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.replace_slice">strings.replace_slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_putcsv</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.delete"></a><h3>r := strings.delete( s, l, h )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return a string with character positions positive l to natural h deleted</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.delete( "bowl", 4, 4 ); -- returns "bow"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>low position to delete (1 is the start of the string).</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the high position to delete.</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string with the positions removed</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad position raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.head">strings.head</a><br><a href="#strings.slice">strings.slice</a><br><a href="#strings.tail">strings.tail</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada.Strings.Unbounded.Delete</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.element"></a><h3>c := strings.element( s, p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the character located at positive position p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">c := strings.element( "baby", 2 ); -- returns 'a'</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the string position (1 is the first character).</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>return value</span></td>
<td><span>character</span></td>
<td><span>required</span></td>
<td><span>the character</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad position raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.delete">strings.delete</a><br><a href="#strings.head">strings.head</a><br><a href="#strings.slice">strings.slice</a><br><a href="#strings.tail">strings.tail</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Element</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.ends_with"></a><h3>b := ends_with( s, t [, c] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if substring t matches the end of string s.  If c is sensitivity.insensitive, the search is insensitive.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.ends_with( "foobar", "bar" ); -- b is true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if strings match</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring to end with</span></td>
</tr>
<tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>strings.sensitivity</span></td>
<td><span>sensitivity.sensitive</span></td>
<td><span>the case sensitivity</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>The tail substring must not be an empty string.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.starts_with">strings.starts_with</a><br><a href="#strings.tail">strings.tail</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_ends_with</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>

<a name="strings.field"></a><h3>r := strings.field( s, c [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return the natural cth substring of s delimited by character d.  A bad position returns an empty string (like the Linux/UNIX cut command).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.field( "a/b/c", 2, '/' ); -- returns "b"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the field position (1 for first field)</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>ASCII.CR</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the field</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.replace">strings.replace</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Perl: split<br>PHP: explode</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.glob"></a><h3>b := strings.glob( e, s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>return true if string glob expression e matches the string s. Globbing characters include:</p>
<ul>
<li>
<b>*</b> - zero or more characters</li>
<li>
<b>?</b> - a single character</li>
<li>
<b>[...]</b> - a set of characters</li>
<li>
<b>[^...]</b> - any not in set of characters</li>
<li>
<b>[c1...c2]</b> - a range of characters between c1 and c2</li>
</ul>
</td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.glob( "app*", "apple" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the glob pattern to use</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the pattern matched</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.index">strings.index</a><br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: GNAT.RegPat.Match</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>This should rightly be strings.match but the name conflicts with the
other strings.match.  Glob also is a more descriptive name.</p></td>
</tr>
</table>

<a name="strings.head"></a><h3>r := strings.head( s, c [, p] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the first natural c characters of string s. If the number of
characters is greater than the strings, the remaining characters will be
padded using character p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.head( "minimum", 3 ); -- returns "min"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of characters (0 for none)</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>' '</span></td>
<td><span>character to pad with if string is short</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad count raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.delete">strings.delete</a><br><a href="#strings.element">strings.element</a><br><a href="#strings.slice">strings.slice</a><br><a href="#strings.starts_with">strings.starts_with</a><br><a href="#strings.tail">strings.tail</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Head</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.image"></a><h3>r := strings.image( n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert numeric or enumerated value n to a string representation of the same value.  For numeric types, it's the inverse of numerics.value.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.image( 35 ); -- returns "35"</span><br>
<span class="code">r := strings.image( true ); -- returns "true"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>numeric or enumerated type</span></td>
<td><span>required</span></td>
<td><span>the value to convert</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the value as a string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="pkg_numerics.html#numerics.value">numerics.value</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: 'image attribute<br>PHP: strval</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.index"></a><h3>n := strings.index( s, p [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the first position of substring p in string s in direction d.  Returns zero if the substring doesn't exist.  The search is case-sensitive.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.index( "catapult", "tap" ); -- returns 3</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring to find</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>strings.direction</span></td>
<td><span>direction.forward</span></td>
<td><span>the direction of the search (forward from start or backward from end)</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the position of the match (0 if none)</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index_non_blank">strings.index_non_blank</a><br><a href="#strings.index_set">strings.index_set</a><br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Index<br>Perl: index / rindex<br>PHP: strpos / strrpos<br>Python: find/index/rfind/rindex</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.index_non_blank"></a><h3>n := strings.index_non_blank( s [,d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the first non-space position in string s in direction d.  Returns zero if the string is all spaces.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.index_non_blank( " moon" ); -- returns 2</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>strings.direction</span></td>
<td><span>direction.forward</span></td>
<td><span>the direction of the search</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the position of the first character that is not a space</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.index_set">strings.index_set</a><br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Index_Non_Blank</p></td>
</tr>
</table>

<a name="strings.index_set"></a><h3>n := strings.index_set( s, t [,f [, m [, d] ] ] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>For string s and a set of characters t, return the first position in s that matches a character in the set (if membership is inside) or doesn't match (if outside).  Start at position f and move in direction d.  Returns zero if the substring doesn't exist or if either string is empty.  The search is case-sensitive.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">? strings.index_set( "marketplace", "place", 1, membership.inside ); -- returns 2</br>? strings.index_set( "marketplace", "mark", 1, membership.outside ); -- returns 5<br>? strings.index_set( "marketplace", "aeiou", 11, membership.outside, direction.backward ); -- returns 10<br>? strings.index_set( "marketplace", "z", 1, membership.inside ); -- return 0 </span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the set of characters</span></td>
</tr>
<tr>
<td><span>f</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>1</span></td>
<td><span>the starting position</span></td>
</tr>
<tr>
<td><span>m</span></td>
<td><span>in</span></td>
<td><span>strings.membership</span></td>
<td><span>membership.inside</span></td>
<td><span>look for characters (inside) or skip characters (outside)</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>strings.direction</span></td>
<td><span>direction.forward</span></td>
<td><span>the direction of the search (forward from start or backward from f)</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the position of the match (0 if none)</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.index_non_blank">strings.index_non_blank</a><br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Index<br>PHP: strspn / strcspn</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Note</p></td>
<td><p>This is equivalent to Ada's Index( s, To_Set( t ) ... ).  Although index_set not a function in Ada, it is allowed under pragma ada_95 due to this similarity.</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>

<a name="strings.insert"></a><h3>r := strings.insert( s, b, n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a string with substring n inserted into string s before position positive b</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.insert( "ale", 2, "pp" ); -- returns "apple"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to insert another string into</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the position to insert the substring</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring to insert</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.overwrite">strings.overwrite</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Insert</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.is_alphanumeric"></a><h3>r := strings.is_alphanumeric( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains alphanumeric characters (that is, the same as is_letter and is_digit).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_alphanumeric( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is alphanumeric</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Alphanumeric<br>PHP: ctype_alnum<br>Python: isalnum</p></td>
</tr>
</table>

<a name="strings.is_basic"></a><h3>r := strings.is_basic( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains basic Latin-1 letters (A..Z, a..z, AE Diphtong, Icelandic Eth, Icelandic Thorn, German Sharp S).   Accented characters are not included.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.basic( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is basic</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Basic<br>Python: isalpha</p></td>
</tr>
</table>

<a name="strings.is_control"></a><h3>r := strings.is_control( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains control characters (ASCII/Latin-1 0..31 and 127..159).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.control( "hello" ); -- returns false</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is control characters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Control<br>PHP: ctype_cntrl</p></td>
</tr>
</table>

<a name="strings.is_digit"></a><h3>r := strings.is_digit( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string completely contains numeric digits (ASCII/Latin-1 48..57).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_digit( "1234567890" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is digits</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Digit<br>PHP: ctype_digit<br>Python: isnumeric</p></td>
</tr>
</table>

<a name="strings.is_fixed"></a><h3>r := strings.is_fixed( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string appears to be a fixed point number (that is, a number with a decimal point).  No check is made to see if the number can be accurately stored by AdaScript.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_fixed( "340.12" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is a number with a decimal point</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.is_graphic"></a><h3>r := strings.is_graphic( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string completely contains printable characters (that is, not is_control).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_graphic( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is printable</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Graphic<br>PHP: ctype_graph</p></td>
</tr>
</table>

<a name="strings.is_hexadecimal_digit"></a><h3>r := strings.is_hexadecimal_digit( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string completely contains hexadecimal numeric characters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_hexadecimal_digit( "FE00" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is hexadecimal</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Hexadecimal_Digit<br>PHP: ctype_xdigit</p></td>
</tr>
</table>

<a name="strings.is_letter"></a><h3>r := strings.is_letter( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains Latin-1 letters (that is, is_basic plus accented characters).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_letter( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is letters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Letter<br>PHP: ctype_alpha<br>Python: isalpha</p></td>
</tr>
</table>

<a name="strings.is_lower"></a><h3>r := strings.is_lower( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains Latin-1 lower-case letters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_lower( "hello" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is lower-case letters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Lower<br>PHP: ctype_lower<br>Python: islower</p></td>
</tr>
</table>

<a name="strings.is_slashed_date"></a><h3>r := strings.is_slashed_date( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string appears to be an 8 or 10 character slashed date.  No check is made to see if the date is a real date.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_slashed_date( "11/22/2003" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is a date</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.is_special"></a><h3>r := strings.is_special( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains special printable characters such as punctuation marks (that is, is_graphic and not is_alphanumeric).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_special( "!" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is special</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Special<br>PHP: ctype_punct</p></td>
</tr>
</table>

<a name="strings.is_typo_of"></a><h3>b := strings.is_typo_of( s1, s2 )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>true if the string s1 is similar to s2.  false if the strings are the same, if the strings are too short to test or if the strings are very different.  The function is case-sensitive.  This is the same algorithm used by SparForte to check for identifiers with spelling mistakes.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.is_typo_of( "apple", "app1e" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s1</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the first string to compare</span></td>
</tr>
<tr>
<td><span>s2</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the second string to compare</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the strings are a possible typo</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: levenshtein / similar_text</p></td>
</tr>
</table>

<a name="strings.is_upper"></a><h3>r := strings.is_upper( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if the string completely contains Latin-1 upper-case letters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.is_upper( "HELLO" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the string is upper-case letters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.is_lower">strings.is_lower</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.Is_Upper<br>PHP: ctype_upper<br>Python: isupper</p></td>
</tr>
</table>

<a name="strings.length"></a><h3>n := strings.length( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the number of characters in the string.  Returns zero if the string is empty.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.length( "bounce" ); -- returns 6</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to count</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of characters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Length<br>PHP: strlen<br>Python: len</p></td>
</tr>
</table>

<a name="strings.levenshtein"></a><h3>b := strings.levenshtein( s1, s2 )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the number of edits to change s1 into s2.</p>
</td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.levenshtein( "kitten", "sitting" ); -- returns 3</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s1</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the first string</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the second string</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of changes</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: levenshtein</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>

<a name="strings.lookup"></a><h3>r := strings.lookup( s, k [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>String s contains pairs of key-value substrings delimited by character d.  Return the right-hand (value) substring of the pair beginning with left-hand (key) field k.  An empty string is returned if the key is not found.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.lookup( "a/b/c/d", "c", '/' ); -- returns "d" from pair "c/d"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>k</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the key to find</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>ASCII.CR</span></td>
<td><span>the character delimiter</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the value of the key</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.index">strings.index</a>_non_blank<br><a href="#strings.match">strings.match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.match"></a><h3>b := strings.match( e, s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return true if the string matches regular expression with PERL extensions.</p>
<p>Match characters include:
<ul>
<li><b>^</b> - at beginning</li> 
<li><b>.</b> - any character</li>
<li><b>$</b> - at end</li>
<li><b>?</b> - zero or one character</li>
<li><b>[s]</b> - any in set s</li>
<li><b>+</b> - one or more characters</li>
<li><b>[^s]</b> - any not in set s</li>
<li><b>*</b> - zero or more characters</li>
<li><b>\</b> - escape character</li>
<li><b>(e)</b> - nested expression</li>
<li><b>|</b> - alternative</li>
</ul></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.match( "^app", "apple" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the regular expression</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the pattern matched</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.index_non_blank">strings.index_non_blank</a><br><a href="#strings.lookup">strings.lookup</a><br><a href="#strings.perl_match">strings.perl_match</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: GNAT.RegExp.Match</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Note</p></td>
<td><p>There's a known bug in GNAT 3.12 and 3.13 which causes strings.match to fail.</p></td>
</tr>
</table>

<a name="strings.mktemp"></a><h3>r := strings.mktemp( p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Make a temporary file name using template p (like UNIX/Linux mktemp command)</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.mktemp( "tempXXXXXX" );</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the path template ending with 6 dummy characters</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>univeral_string</span></td>
<td><span>required</span></td>
<td><span>the path with the dummy characters replaced with random characters</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: tempnam</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.perl_match"></a><h3>b := strings.perl_match( e, s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return true if the string matches Perl Compatible regular expression.
This has more features than strings.match.</p>
</td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.perl_match( "^app", "apple" ); -- returns true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the PCRE regular expression</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if the pattern matched</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>Various errors may be returned by the C function</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.csv_field">strings.csv_field</a><br><a href="#strings.field">strings.field</a><br><a href="#strings.glob">strings.glob</a><br><a href="#strings.match">strings.match</a><br><a href="#strings.index">strings.index</a><br><a href="#strings.index_non_blank">strings.index_non_blank</a><br><a href="#strings.lookup">strings.lookup</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Perl: m//<br>PHP: preg_match</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.2.1</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Note</p></td>
<td><p>Uses the C pcre library.</p></td>
</tr>
</table>

<a name="strings.overwrite"></a><h3>r := strings.overwrite( s, p, n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a string with substring n overwriting positions starting at positive p</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.overwrite( "goose", 2, "ee" ); -- returns "geese"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to overwrite</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the position to start replacing characters</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the substring to replace characters with</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.insert">strings.insert</a><br><a href="#strings.replace_slice">strings.replace_slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Overwrite<br>PHP: substr_replace</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.replace"></a><h3>strings.replace( s, f, t [, d] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>s contains substring fields delimited by character d.  Replace the fth substring field with new substring t.  No change is made for a position that doesn't exist.  </p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.replace( s, 2, "*", '/' ); -- if s is "a/b/c", it is now "a/*/c"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>f</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the index of the field to change</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new substring</span></td>
</tr>
<tr>
<td><span>d</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>ASCII.CR</span></td>
<td><span>the character delimiter</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad low position will raise an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.field">strings.field</a><br><a href="#strings.lookup">strings.lookup</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Python: replace</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.replace_all"></a><h3>r := replace_all( s, n, t [, c] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Replace all occurrences of substring n in string s with replacement substring t.  If c is sensitivity.insensitive, the search is insensitive.  The search is first position to last position.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.replace_all( "foobar", "o", "x", true ); -- r is "fxxbar"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring to find</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new substring</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>strings.sensitivity</span></td>
<td><span>sensitivity.sensitive</span></td>
<td><span>the case sensitivity</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>The needle must not be an empty string.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.replace_slice">strings.replace_slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_replace / str_ireplace</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>

<a name="strings.replace_slice"></a><h3>r := replace_slice( s, l, h, b )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Replace the characters in s between positions low l and high h with substring b</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.replace_slice( s, 2, 3, , 'foo' ); -- if s is "1234", r is "1foo34"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>the position of the first character</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the position of the last character</span></td>
</tr>
<tr>
<td><span>b</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad low position will raise an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.insert">strings.insert</a><br><a href="#strings.overwrite">strings.overwrite</a><br><a href="#strings.replace_all">strings.replace_all</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.set_unbounded_string"></a><h3>strings.set_unbounded_string( u, s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Set unbounded string u with the value of string s.  Provided for Ada 2005 compatibility.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.set_unbounded_string( u, "foo" ); -- u is now "foo"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>u</span></td>
<td><span>in out</span></td>
<td><span>unbounded_string</span></td>
<td><span>required</span></td>
<td><span>the string to set</span></td>
</tr>
<tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the string to provide the value</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Set_Unbounded_String</p></td>
</tr>
</table>

<a name="strings.slice"></a><h3>r := strings.slice( s, l, h )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a substring between the positions positive l and natural h.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.slice( "realize", 2, 4 ); -- returns "eal"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to overwrite</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>low position to start replacing characters</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>high position to finish replacing characters</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad low position will raise an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Slice<br>PHP: substr</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.soundex"></a><h3>r := strings.soundex( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the English language Soundex code representing the sound of the string.
The codes can be used to compare strings by their sound when the precise spelling
is uncertain.
Extended characters will be converted to basic characters.  An empty string will
return an empty string.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.soundex( "Soundex" ); -- returns "S532"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to evaluate</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the Soundex code</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: soundex</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>

<a name="strings.split"></a><h3>strings.split( s, l, r , p )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Split string s into a left substring l and a right substring r at or to the left of character position p.  split will attempt to split on the nearest space.  A bad position will be constrained to legal values.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">strings.split( "hello there", l, r, 9 ); -- l is "hello " and r is "there"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to split</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the left substring of s</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the right substring of s</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the maximum width of the left substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="pkg_doubly.html#doubly_linked_lists.parcel">doubly_linked_lists.parcel</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: wordwrap</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.starts_with"></a><h3>b := starts_with( s, t [, c] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>True if substring t matches the start of string s.  If c is sensitivity.insensitive, the search is insensitive.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">b := strings.starts_with( "foobar", "foo" ); -- b is true</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>b</span></td>
<td><span>return value</span></td>
<td><span>boolean</span></td>
<td><span>required</span></td>
<td><span>true if strings match</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in out</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to test</span></td>
</tr>
<tr>
<td><span>t</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring to start with</span></td>
</tr>
<tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>strings.sensitivity</span></td>
<td><span>sensitivity.sensitive</span></td>
<td><span>the case sensitivity</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>The head substring must not be an empty string.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.ends_with">strings.ends_with</a><br><a href="#strings.head">strings.head</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_starts_with</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>

<a name="strings.tail"></a><h3>r := strings.tail( s, c [, p] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the last natural c characters of string s</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.tail( "maximum", 3 ); -- returns "mum"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to search</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of characters (0 for none)</span></td>
</tr>
<tr>
<td><span>p</span></td>
<td><span>in</span></td>
<td><span>character</span></td>
<td><span>' '</span></td>
<td><span>character to pad with if string is short</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the substring</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>A bad count raises an exception.</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.delete">strings.delete</a><br><a href="#strings.element">strings.element</a><br><a href="#strings.ends_with">strings.ends_with</a><br><a href="#strings.head">strings.head</a><br><a href="#strings.slice">strings.slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Tail</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.to_base64"></a><h3>r := strings.to_base64( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Encode to arbitrary (possibly binary) string to base 64 characters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_base64( "foobar" &amp; ASCII.FF ); -- returns "Zm9vcmJhcgw="</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to encode</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the encoded string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.to_string">strings.to_string</a></p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.0.3</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td>-</td>
</tr>
</table>

<a name="strings.to_basic"></a><h3>r := strings.to_basic( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert the string to basic letters (as defined for strings.is_basic).</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_basic( "hello" ); -- returns "hello"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the basic string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.is_basic">strings.is_basic</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Character_Handling.To_Basic</p></td>
</tr>
</table>

<a name="strings.to_escaped"></a><h3>r := strings.to_escaped( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert the string to printable character by replacing control characters with "[# n]" where n is the ASCII/Latin-1 position.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_escaped( "hello" &amp; ASCII.CR ); -- returns "hello[# 13]"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the escaped string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.to_hexadecimal_digits"></a><h3>s := strings.to_hexadecimal_digits( n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a natural number as upper-case hexadecimal digits.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.to_hexadecimal_digits( 123 ); -- returns "7B"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number to convert</span></td>
</tr>
<tr>
<td><span>s</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the hexadecimal string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>to_hexadecimal_digits introduced with SparForte 2.4.1</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: dechex<br>Python: hex</p></td>
</tr>
</table>

<a name="strings.to_lower"></a><h3>r := strings.to_lower( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the string in lower-case</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_lower( "bOunce" ); -- returns "bounce"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the lower-case string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: strtolower<br>Python: lower</p></td>
</tr>
</table>

<a name="strings.to_proper"></a><h3>r := strings.to_proper( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the string in proper (or mixed or title) case</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.to_proper( "proper" ); -- returns "Proper"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the proper-case string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: ucwords</p></td>
</tr>
</table>

<a name="strings.to_json"></a><h3>r := strings.to_json( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the JSON encoding of the string.  Encoding arbitrary control characters with \u is not yet supported, though carriage returns, line feeds, etc. are supported.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.to_json( "foobar" &amp; ASCII.LF &amp; "test" ); -- returns "foobar\ntest"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string expression to encode</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>json_string</span></td>
<td><span>required</span></td>
<td><span>the JSON string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.to_string">strings.to_string</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: json_encode</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.to_string"></a><h3>r := strings.to_string( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>The function depends on the string type.</p>
<ol>
<li>If s is an <b>unbounded_string</b>, convert unbounded string s to string r.  For compatibility with Ada 95.</li>
<li>If s is a <b>json_string</b>, convert JSON encoding of a string into the original string r. Encoding arbitrary control characters with \u is not yet supported, though carriage returns, line feeds, etc. are supported. universal_string types (including string literals) are not accepted.</li>
<li> If s is a <b>strings.base64_string</b>, return an arbitrary (possibly binary) string r as decoded from the base 64 characters s.</li></td>

</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">s := strings.to_string( some_unbounded_string );<br>r := strings.to_string( json_string( ASCII.Quotation &amp; "foobar\ntest" &amp; ASCII.Quotation ) ); -- returns a string with foobar, a line feed, and test<br>r := strings.to_string( strings.base64_string( "Zm9vcmJhcgw=" ) ); -- returns "foobar" and a form feed</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the string expression to decode</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the converted/decoded string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>Bad JSON data can raise exceptions<br>NAME_ERROR, STATUS_ERROR, DATA_ERROR, END_ERROR possible with Base64 strings</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="pkg_arrays.html#arrays.to_array">arrays.to_array</a><br><a href="pkg_records.html#records.to_record">records.to_record</a><br><a href="#strings.to_base64">strings.to_base64</a><br><a href="#strings.to_json">strings.to_json</a></p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>Base 64 introduced with SparForte 2.0.3</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.To_String<br>PHP: json_decode</p></td>
</tr>
</table>

<a name="strings.to_unbounded_string"></a><h3>u := strings.to_unbounded_string( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Convert string s to unbounded string u.  For compatibility with Ada 95.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">unbounded_string := strings.to_unbounded_string( "test" );</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string</span></td>
<td><span>required</span></td>
<td><span>the fixed string to covert</span></td>
</tr>
<tr>
<td><span>u</span></td>
<td><span>return value</span></td>
<td><span>unbounded_string</span></td>
<td><span>required</span></td>
<td><span>the unbounded string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>-</p></td>
</tr>
</table>

<a name="strings.to_upper"></a><h3>r := strings.to_upper( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the string in upper-case</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.to_upper( "BoUNCE" ); -- returns "BOUNCE"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>string or character type</span></td>
<td><span>required</span></td>
<td><span>the string to change</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the upper-case string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.is_upper">strings.is_upper</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: strtoupper<br>Python: upper</p></td>
</tr>
</table>

<a name="strings.trim"></a><h3>r := strings.trim( s [, e] )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Remove leading and/or trailing spaces (depending on e) from string s</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.trim( "&nbsp; many&nbsp; " ); -- returns "many"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to trim</span></td>
</tr>
<tr>
<td><span>e</span></td>
<td><span>in</span></td>
<td><span>strings.trim_end</span></td>
<td><span>trim_end.both</span></td>
<td><span>the end(s) of string to trim</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Trim<br>PHP: trim<br>Python: strip</p></td>
</tr><tr>
<td><p class="pkg_label">Implementation Notes</p></td>
<td><p>Parameters changed to universal_strings for SparForte 2.2</p></td>
</tr>
</table>

<a name="strings.unbounded_slice"></a><h3>r := strings.unbounded_slice( s, l, h )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return a substring between the positions positive l and natural h.  For compatibility with Ada&mdash;normally use strings.slice.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.unbounded_slice( "realize", 2, 4 ); -- returns "eal"</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to overwrite</span></td>
</tr>
<tr>
<td><span>l</span></td>
<td><span>in</span></td>
<td><span>positive</span></td>
<td><span>required</span></td>
<td><span>low position to start replacing characters</span></td>
</tr>
<tr>
<td><span>h</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>high position to finish replacing characters</span></td>
</tr>
<tr>
<td><span>r</span></td>
<td><span>return value</span></td>
<td><span>unbounded_string</span></td>
<td><span>required</span></td>
<td><span>the new string</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p><a href="#strings.slice">strings.slice</a></p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: Ada.Strings.Unbounded.Unbounded_Slice</p></td>
</tr>
</table>

<a name="strings.val"></a><h3>c := strings.val( n )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the ASCII character with value n (inverse of numerics.pos)</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">r := strings.val( 65 ); -- returns 'A'</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>n</span></td>
<td><span>in</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the ASCII value</span></td>
</tr>
<tr>
<td><span>c</span></td>
<td><span>return value</span></td>
<td><span>character</span></td>
<td><span>required</span></td>
<td><span>the character</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>Ada: 'val attribute<br>PHP: ord</p></td>
</tr>
</table>

<a name="strings.word_count"></a><h3>n := strings.word_count( s )</h3>
<table cellspacing="0" cellpadding="0" width="98%" summary="package call">
<tr>
<td width="15%">&nbsp;</td>
<td><p>Return the number of words in a string, where a word is a sequence of letters.</p></td>
</tr><tr>
<td><p class="pkg_label">Example</p></td>
<td><span class="code">n := strings.word_count( "night fall" ); -- returns 2</span></td>
</tr><tr>
<td><p class="pkg_label">Parameters</p></td>
<td><table CELLSPACING=0 CELLPADDING=0 WIDTH="100%" border="0" >
<tr>
<td><span class="pkg_param">Param</span></td>
<td><span class="pkg_param">Mode</span></td>
<td><span class="pkg_param">Type</span></td>
<td><span class="pkg_param">Default</span></td>
<td><span class="pkg_param">Description</span></td>
</tr><tr>
<td><span>s</span></td>
<td><span>in</span></td>
<td><span>universal_string</span></td>
<td><span>required</span></td>
<td><span>the string to check</span></td>
</tr>
<td><span>n</span></td>
<td><span>return value</span></td>
<td><span>natural</span></td>
<td><span>required</span></td>
<td><span>the number of words (0 if none)</span></td>
</tr>
</table></td>
</tr><tr>
<td><p class="pkg_label">Exceptions</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">See Also</p></td>
<td><p>-</p></td>
</tr><tr>
<td><p class="pkg_label">Restrictions</p></td>
<td><p>Not allowed with pragma ada_95</p>
</tr><tr>
<td><p class="pkg_label">Compare With</p></td>
<td><p>PHP: str_word_count</p></td>
</tr><tr>
<td><p class="pkg_label">Introduced</p></td>
<td><p>SparForte 2.4.2</p></td>
</tr>
</table>


&nbsp;<br>

			</td>
			<td bgcolor="#d3c7f8" width="150" align="right" valign="top"><noscript><hr /></noscript><img src="art/right_menu_top.png" width="150" height="24" alt="[Right Submenu]"><br><a name="submenu"></a>
                                <p class="rmt"><a class="rightmenutext" href="packages.html">&nbsp;Summary</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_arrays.html">&nbsp;arrays</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_btree_io.html">&nbsp;btree_io</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_calendar.html">&nbsp;calendar</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_cgi.html">&nbsp;cgi</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_chains.html">&nbsp;chains</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_cmdline.html">&nbsp;command_line</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_db.html">&nbsp;db/ postgresql</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_dbm.html">&nbsp;dbm</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_dirops.html">&nbsp;directory_operations</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_doubly.html">&nbsp;doubly_linked...</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_dht.html">&nbsp;dynamic_hash_...</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_enums.html">&nbsp;enums</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_exceptions.html">&nbsp;exceptions</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_files.html">&nbsp;files</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_gnat_cgi.html">&nbsp;gnat.cgi</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_gnat_crc32.html">&nbsp;gnat.crc32</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_hash_io.html">&nbsp;hash_io</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_hmaps.html">&nbsp;hashed_maps</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_l10n.html">&nbsp;l10n</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_lock_files.html">&nbsp;lock_files</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_logs.html">&nbsp;logs</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_memcache.html">&nbsp;memcache</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_memcache_highread.html">&nbsp;memcache.highread</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_mysql.html">&nbsp;mysql</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_mysqlm.html">&nbsp;mysqlm</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_numerics.html">&nbsp;numerics</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_os.html">&nbsp;os</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_pen.html">&nbsp;pen</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_pengl.html">&nbsp;pen (OpenGL)</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_records.html">&nbsp;records</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_sound.html">&nbsp;sound</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_sinfo.html">&nbsp;source_info</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_stats.html">&nbsp;stats</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_strings.html">&nbsp;<b>strings</b></a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_system.html">&nbsp;System</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_teams.html">&nbsp;teams</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_templates.html">&nbsp;templates</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_text_io.html">&nbsp;text_io</a></p>
                                <p class="rmt"><a class="rightmenutext" href="pkg_units.html">&nbsp;units</a></p>
</a></p>

			</td>
		</tr>
		<tr>
			<td bgcolor="#d3c7f8" align="left" valign="middle"><a href="#top"><img src="art/up_arrow.png" border="0" width="24" height="27" alt="[Back to Top]"><span>&nbsp;Back To Top</span></a></td>
			<td bgcolor="#d3c7f8" align="center" valign="middle"><img src="art/forte_small.png" width="26" height="32" border="0" alt="[Small Forte Symbol]"></td>
	       	</tr>

	</table>

</body>
</html>

